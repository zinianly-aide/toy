<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>微积分在经济学中的应用 | 微积分直观理解</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- 引入Chart.js用于数据可视化 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    
    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#2563eb',
                        secondary: '#7c3aed',
                        accent: '#f97316',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        math: ['STIX Two Math', 'serif']
                    }
                }
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .canvas-container {
                @apply relative bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg;
            }
            .section-fade {
                @apply opacity-0 translate-y-8 transition-all duration-700;
            }
            .section-visible {
                @apply opacity-100 translate-y-0;
            }
        }
    </style>
    
    <style>
        /* 基础样式 */
        html {
            scroll-behavior: smooth;
        }
        
        body {
            background-color: #f8fafc;
        }
        
        /* 数学符号显示优化 */
        .math-expression {
            font-family: 'STIX Two Math', serif;
            font-size: 1.1em;
        }
        
        /* Canvas容器样式 */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* 滚动条样式优化 */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
    </style>
</head>

<body class="font-sans text-dark">
    <!-- 导航栏 -->
    <header id="navbar" class="fixed w-full z-50 transition-all duration-300 bg-white/90 backdrop-blur-sm shadow-sm">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-calculator text-primary text-2xl"></i>
                <h1 class="text-xl md:text-2xl font-bold text-primary">微积分直观理解</h1>
            </div>
            
            <!-- 桌面导航 -->
            <nav class="hidden md:flex space-x-8">
                <a href="calculus-tutorial.html#intro" class="text-dark/80 hover:text-primary transition-colors">简介</a>
                <a href="calculus-tutorial.html#derivative" class="text-dark/80 hover:text-primary transition-colors">导数</a>
                <a href="calculus-tutorial.html#integral" class="text-dark/80 hover:text-primary transition-colors">积分</a>
                <a href="calculus-tutorial.html#theorem" class="text-dark/80 hover:text-primary transition-colors">微积分基本定理</a>
                <a href="calculus-tutorial.html#applications" class="text-primary font-medium">应用</a>
            </nav>
            
            <!-- 移动端菜单按钮 -->
            <button id="menu-toggle" class="md:hidden text-dark text-xl">
                <i class="fa fa-bars"></i>
            </button>
        </div>
        
        <!-- 移动端导航菜单 -->
        <div id="mobile-menu" class="hidden md:hidden bg-white border-t">
            <div class="container mx-auto px-4 py-2 flex flex-col space-y-3">
                <a href="calculus-tutorial.html#intro" class="py-2 text-dark/80 hover:text-primary transition-colors">简介</a>
                <a href="calculus-tutorial.html#derivative" class="py-2 text-dark/80 hover:text-primary transition-colors">导数</a>
                <a href="calculus-tutorial.html#integral" class="py-2 text-dark/80 hover:text-primary transition-colors">积分</a>
                <a href="calculus-tutorial.html#theorem" class="py-2 text-dark/80 hover:text-primary transition-colors">微积分基本定理</a>
                <a href="calculus-tutorial.html#applications" class="py-2 text-primary font-medium">应用</a>
            </div>
        </div>
    </header>

    <!-- 英雄区域 -->
    <section class="pt-24 pb-16 md:pt-32 md:pb-24 bg-gradient-to-br from-secondary/5 to-primary/5">
        <div class="container mx-auto px-4">
            <div class="max-w-4xl mx-auto text-center">
                <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold mb-6 text-dark text-shadow">
                    微积分在<span class="text-secondary">经济学</span>中的应用
                </h1>
                <p class="text-lg md:text-xl text-dark/70 mb-10">
                    探索微积分如何帮助经济学家分析市场行为、优化决策和预测经济趋势
                </p>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <a href="#marginal-analysis" class="px-8 py-3 bg-secondary text-white rounded-lg font-medium hover:bg-secondary/90 transition-all shadow-md hover:shadow-lg transform hover:-translate-y-1">
                        开始探索 <i class="fa fa-arrow-right ml-2"></i>
                    </a>
                    <a href="calculus-tutorial.html#applications" class="px-8 py-3 bg-white text-secondary border border-secondary rounded-lg font-medium hover:bg-secondary/5 transition-all">
                        返回应用列表
                    </a>
                </div>
            </div>
        </div>
    </section>

    <main class="container mx-auto px-4 py-12">
        <!-- 边际分析部分 -->
        <section id="marginal-analysis" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-secondary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">边际分析：决策的数学基础</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div>
                    <h3 class="text-2xl font-semibold mb-4">边际概念的微积分解释</h3>
                    <p class="mb-4">
                        在经济学中，"边际"指的是自变量变化一个单位时，因变量的变化量。这个概念直接对应于微积分中的导数。
                    </p>
                    <p class="mb-4">
                        对于一个经济函数 <span class="math-expression">f(x)</span>，其边际函数就是它的导数 <span class="math-expression">f'(x)</span>。
                    </p>
                    <div class="space-y-4 mb-6">
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">边际成本 (MC) = dC/dQ</span> （成本函数对产量的导数）
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">边际收益 (MR) = dR/dQ</span> （收益函数对产量的导数）
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">边际利润 (MP) = dπ/dQ = MR - MC</span> （利润函数对产量的导数）
                        </div>
                    </div>
                    <p class="mb-4">
                        企业利润最大化的条件是：边际收益等于边际成本（MR = MC），这正是微积分中求极值的条件（导数为零）。
                    </p>
                </div>
                
                <div class="canvas-container h-96">
                    <canvas id="marginalAnalysisCanvas"></canvas>
                    <div class="absolute top-3 left-3 flex flex-col space-y-2">
                        <div class="bg-white px-3 py-1 rounded-lg shadow-sm text-sm">
                            <span class="font-medium">利润最大化点：</span>
                            <span id="maxProfitPoint">MR = MC</span>
                        </div>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        边际收益与边际成本曲线交点决定最优产量
                    </div>
                </div>
            </div>
        </section>

        <!-- 弹性分析部分 -->
        <section id="elasticity" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-primary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">弹性分析：需求量对价格的敏感度</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div class="canvas-container h-96">
                    <canvas id="elasticityCanvas"></canvas>
                    <div class="absolute top-3 right-3 flex space-x-2">
                        <button id="prevElasticity" class="p-2 bg-primary/10 hover:bg-primary/20 rounded-full transition-colors">
                            <i class="fa fa-arrow-left text-primary"></i>
                        </button>
                        <button id="nextElasticity" class="p-2 bg-primary/10 hover:bg-primary/20 rounded-full transition-colors">
                            <i class="fa fa-arrow-right text-primary"></i>
                        </button>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        不同弹性的需求曲线
                    </div>
                </div>
                
                <div>
                    <h3 class="text-2xl font-semibold mb-4">需求价格弹性</h3>
                    <p class="mb-4">
                        需求价格弹性衡量商品需求量对价格变化的反应程度，它是微积分中相对变化率的应用。
                    </p>
                    <div class="bg-white p-4 rounded-lg shadow-sm mb-6 text-center">
                        <span class="math-expression text-xl">需求价格弹性 (E<sub>d</sub>) = (dQ/dP) * (P/Q)</span>
                    </div>
                    <p class="mb-4">
                        其中：
                    </p>
                    <ul class="space-y-2 mb-6">
                        <li class="flex items-start">
                            <i class="fa fa-arrow-right text-primary mt-1 mr-2"></i>
                            <span><span class="math-expression">|E<sub>d</sub>| > 1</span>：富有弹性，价格变化对需求量影响大</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-arrow-right text-primary mt-1 mr-2"></i>
                            <span><span class="math-expression">|E<sub>d</sub>| = 1</span>：单位弹性，价格变化对总收益无影响</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-arrow-right text-primary mt-1 mr-2"></i>
                            <span><span class="math-expression">|E<sub>d</sub>| < 1</span>：缺乏弹性，价格变化对需求量影响小</span>
                        </li>
                    </ul>
                    <p class="mb-4">
                        企业可以利用需求弹性来制定价格策略，最大化总收益。
                    </p>
                </div>
            </div>
        </section>

        <!-- 消费者剩余与生产者剩余 -->
        <section id="surplus" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-accent rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">消费者剩余与生产者剩余</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div>
                    <h3 class="text-2xl font-semibold mb-4">福利经济学中的积分应用</h3>
                    <p class="mb-4">
                        消费者剩余和生产者剩余是衡量市场效率的重要指标，它们的计算需要用到积分。
                    </p>
                    <div class="space-y-4 mb-6">
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">消费者剩余 (CS) = ∫₀^Q* (D(Q) - P*) dQ</span>
                            <p class="text-sm text-dark/60 mt-1">需求曲线以下、市场价格以上的面积</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">生产者剩余 (PS) = ∫₀^Q* (P* - S(Q)) dQ</span>
                            <p class="text-sm text-dark/60 mt-1">供给曲线以上、市场价格以下的面积</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">总剩余 (TS) = CS + PS</span>
                            <p class="text-sm text-dark/60 mt-1">市场总福利</p>
                        </div>
                    </div>
                    <p class="mb-4">
                        在完全竞争市场中，市场均衡时总剩余达到最大化，这是福利经济学第一定理的核心内容。
                    </p>
                </div>
                
                <div class="canvas-container h-96">
                    <canvas id="surplusCanvas"></canvas>
                    <div class="absolute top-3 left-3 flex flex-col space-y-2">
                        <div class="flex items-center space-x-2">
                            <span class="inline-block w-3 h-3 bg-primary/30 rounded-full mr-1"></span>
                            <span class="text-sm">消费者剩余</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="inline-block w-3 h-3 bg-secondary/30 rounded-full mr-1"></span>
                            <span class="text-sm">生产者剩余</span>
                        </div>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        市场均衡时的消费者剩余与生产者剩余
                    </div>
                </div>
            </div>
        </section>

        <!-- 最优化问题 -->
        <section id="optimization" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-secondary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">经济最优化问题</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div class="canvas-container h-96">
                    <canvas id="optimizationCanvas"></canvas>
                    <div class="absolute top-3 right-3 flex space-x-2">
                        <button id="changeBudget" class="p-2 bg-secondary/10 hover:bg-secondary/20 rounded-full transition-colors">
                            <i class="fa fa-refresh text-secondary"></i>
                        </button>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        消费者效用最大化：预算线与无差异曲线的切点
                    </div>
                </div>
                
                <div>
                    <h3 class="text-2xl font-semibold mb-4">消费者选择理论</h3>
                    <p class="mb-4">
                        消费者在预算约束下最大化效用是经济学中的经典最优化问题，可以用微积分中的拉格朗日乘数法解决。
                    </p>
                    <div class="bg-white p-4 rounded-lg shadow-sm mb-6">
                        <p class="font-medium mb-2">最大化：</p>
                        <span class="math-expression">U(x, y)</span> （效用函数）
                        <p class="font-medium mt-3 mb-2">受约束于：</p>
                        <span class="math-expression">pₓx + pᵧy = I</span> （预算约束）
                    </div>
                    <p class="mb-4">
                        最优解的条件是边际替代率等于价格比：
                    </p>
                    <div class="bg-white p-4 rounded-lg shadow-sm mb-6 text-center">
                        <span class="math-expression text-xl">MRS = pₓ/pᵧ</span>
                    </div>
                    <p class="mb-4">
                        其中边际替代率 (MRS) 是无差异曲线的斜率，等于两种商品边际效用之比：
                    </p>
                    <div class="bg-white p-4 rounded-lg shadow-sm mb-6 text-center">
                        <span class="math-expression text-xl">MRS = MUₓ/MUᵧ = (∂U/∂x)/(∂U/∂y)</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 动态分析与增长模型 -->
        <section id="dynamic-analysis" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-primary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">动态分析与经济增长模型</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div>
                    <h3 class="text-2xl font-semibold mb-4"> Solow 增长模型</h3>
                    <p class="mb-4">
                        经济增长理论中，Solow 模型是一个经典的动态模型，它使用微积分来描述资本积累和经济增长的过程。
                    </p>
                    <div class="space-y-4 mb-6">
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">Y = F(K, AL)</span> （生产函数）
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">Δk = s·f(k) - (n + δ + g)·k</span> （资本积累方程）
                            <p class="text-sm text-dark/60 mt-1">其中k是人均资本，s是储蓄率，n是人口增长率，δ是折旧率，g是技术进步率</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <span class="math-expression">当Δk = 0时，经济达到稳态</span>
                        </div>
                    </div>
                    <p class="mb-4">
                        通过分析这个微分方程，经济学家可以预测不同政策和参数变化对经济增长路径的影响。
                    </p>
                </div>
                
                <div class="canvas-container h-96">
                    <canvas id="growthModelCanvas"></canvas>
                    <div class="absolute top-3 left-3 flex flex-col space-y-2">
                        <div class="flex items-center space-x-2">
                            <button id="decreaseSaving" class="p-2 bg-primary/10 hover:bg-primary/20 rounded-full transition-colors">
                                <i class="fa fa-minus text-primary"></i>
                            </button>
                            <span id="savingRateValue" class="text-sm bg-white px-2 py-1 rounded shadow-sm">储蓄率: 20%</span>
                            <button id="increaseSaving" class="p-2 bg-primary/10 hover:bg-primary/20 rounded-full transition-colors">
                                <i class="fa fa-plus text-primary"></i>
                            </button>
                        </div>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        Solow增长模型中的稳态分析
                    </div>
                </div>
            </div>
        </section>

        <!-- 实际案例研究 -->
        <section id="case-studies" class="max-w-5xl mx-auto mb-10 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-accent rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">实际案例研究</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <!-- 案例1：定价策略 -->
                <div class="bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg">
                    <div class="h-48 bg-secondary/10 flex items-center justify-center">
                        <i class="fa fa-tags text-secondary text-6xl"></i>
                    </div>
                    <div class="p-5">
                        <h3 class="text-xl font-semibold mb-2">动态定价策略</h3>
                        <p class="text-dark/70 mb-4">
                            航空公司、酒店和电商平台使用基于微积分的动态定价模型，根据需求弹性、时间因素和竞争情况实时调整价格，最大化收益。
                        </p>
                        <div class="bg-secondary/5 p-3 rounded-lg">
                            <span class="math-expression">P(t) = P₀ + α·D(t) + β·t + γ·C(t)</span>
                            <p class="text-sm text-dark/60 mt-1">动态价格模型，考虑需求、时间和竞争因素</p>
                        </div>
                    </div>
                </div>
                
                <!-- 案例2：资源配置 -->
                <div class="bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg">
                    <div class="h-48 bg-primary/10 flex items-center justify-center">
                        <i class="fa fa-pie-chart text-primary text-6xl"></i>
                    </div>
                    <div class="p-5">
                        <h3 class="text-xl font-semibold mb-2">投资组合优化</h3>
                        <p class="text-dark/70 mb-4">
                            现代投资组合理论使用微积分来解决在给定风险水平下最大化预期收益的优化问题，这是资本资产定价模型(CAPM)的基础。
                        </p>
                        <div class="bg-primary/5 p-3 rounded-lg">
                            <span class="math-expression">max E[Rₚ] - λ·Var(Rₚ)</span>
                            <p class="text-sm text-dark/60 mt-1">在风险约束下最大化预期收益</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-12">
        <div class="container mx-auto px-4">
            <div class="max-w-5xl mx-auto">
                <div class="flex flex-col md:flex-row justify-between items-center mb-8">
                    <div class="flex items-center space-x-2 mb-4 md:mb-0">
                        <i class="fa fa-calculator text-primary text-2xl"></i>
                        <h2 class="text-xl font-bold">微积分直观理解</h2>
                    </div>
                    <div class="flex space-x-6">
                        <a href="calculus-tutorial.html#intro" class="text-white/70 hover:text-primary transition-colors">简介</a>
                        <a href="calculus-tutorial.html#derivative" class="text-white/70 hover:text-primary transition-colors">导数</a>
                        <a href="calculus-tutorial.html#integral" class="text-white/70 hover:text-primary transition-colors">积分</a>
                        <a href="calculus-tutorial.html#applications" class="text-white/70 hover:text-primary transition-colors">应用</a>
                    </div>
                </div>
                
                <div class="border-t border-white/10 pt-8 text-center text-white/60 text-sm">
                    <p>© 2023 微积分直观理解. 本网站旨在通过交互式可视化帮助理解微积分概念。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- JavaScript代码 -->
    <script>
        // 导航栏滚动效果
        window.addEventListener('scroll', function() {
            const navbar = document.getElementById('navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('py-2', 'shadow');
                navbar.classList.remove('py-3');
            } else {
                navbar.classList.add('py-3');
                navbar.classList.remove('py-2', 'shadow');
            }
        });
        
        // 移动端菜单切换
        document.getElementById('menu-toggle').addEventListener('click', function() {
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenu.classList.toggle('hidden');
        });
        
        // 滚动动画
        const sections = document.querySelectorAll('.section-fade');
        
        function checkVisibility() {
            sections.forEach(section => {
                const sectionTop = section.getBoundingClientRect().top;
                const windowHeight = window.innerHeight;
                
                if (sectionTop < windowHeight * 0.85) {
                    section.classList.add('section-visible');
                }
            });
        }
        
        // 初始检查
        window.addEventListener('load', checkVisibility);
        // 滚动时检查
        window.addEventListener('scroll', checkVisibility);
        
        // 边际分析画布
        const marginalAnalysisCtx = document.getElementById('marginalAnalysisCanvas').getContext('2d');
        
        function drawMarginalAnalysis() {
            const canvas = document.getElementById('marginalAnalysisCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.parentElement.clientWidth;
            const height = canvas.height = canvas.parentElement.clientHeight;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(50, height - 50);
            ctx.lineTo(width - 30, height - 50);
            ctx.stroke();
            
            // 绘制网格
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 50 + i * (width - 80) / 10;
                ctx.beginPath();
                ctx.moveTo(x, 50);
                ctx.lineTo(x, height - 50);
                ctx.stroke();
            }
            for (let i = 0; i <= 6; i++) {
                const y = 50 + i * (height - 100) / 6;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 30, y);
                ctx.stroke();
            }
            
            // 绘制边际收益曲线 (MR)
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let q = 0; q <= 100; q += 1) {
                const x = 50 + q * (width - 80) / 100;
                const mr = 100 - 2 * q;
                const y = height - 50 - mr * (height - 100) / 200;
                if (q === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制边际成本曲线 (MC)
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let q = 0; q <= 100; q += 1) {
                const x = 50 + q * (width - 80) / 100;
                const mc = 20 + q;
                const y = height - 50 - mc * (height - 100) / 200;
                if (q === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 找出MR=MC的交点
            const qOptimal = (100 - 20) / 3; // 解方程 100-2q = 20+q
            const pOptimal = 100 - qOptimal; // 假设需求曲线是 P=100-Q
            
            // 标记最优产量点
            const xOptimal = 50 + qOptimal * (width - 80) / 100;
            const yOptimal = height - 50 - (100 - 2 * qOptimal) * (height - 100) / 200;
            
            ctx.fillStyle = '#2563eb';
            ctx.beginPath();
            ctx.arc(xOptimal, yOptimal, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制连接到坐标轴的虚线
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(xOptimal, yOptimal);
            ctx.lineTo(xOptimal, height - 50);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(xOptimal, yOptimal);
            ctx.lineTo(50, yOptimal);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制图例
            ctx.fillStyle = '#7c3aed';
            ctx.fillRect(30, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('边际收益 (MR)', 50, 30);
            
            ctx.fillStyle = '#f97316';
            ctx.fillRect(150, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('边际成本 (MC)', 170, 30);
            
            // 更新最大利润点信息
            document.getElementById('maxProfitPoint').textContent = `Q* = ${qOptimal.toFixed(1)}, P* = ${pOptimal.toFixed(1)}`;
        }
        
        // 弹性分析画布
        const elasticityCtx = document.getElementById('elasticityCanvas').getContext('2d');
        let currentElasticityIndex = 0;
        const elasticityTypes = [
            { name: '富有弹性', demand: p => 200 - 2 * p, elasticity: '|E_d| > 1' },
            { name: '单位弹性', demand: p => Math.sqrt(10000 - p*p), elasticity: '|E_d| = 1' },
            { name: '缺乏弹性', demand: p => 100 - 0.5 * p, elasticity: '|E_d| < 1' }
        ];
        
        function drawElasticity() {
            const canvas = document.getElementById('elasticityCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.parentElement.clientWidth;
            const height = canvas.height = canvas.parentElement.clientHeight;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            const elasticity = elasticityTypes[currentElasticityIndex];
            
            // 绘制坐标轴
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(50, height - 50);
            ctx.lineTo(width - 30, height - 50);
            ctx.stroke();
            
            // 绘制网格
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 50 + i * (width - 80) / 10;
                ctx.beginPath();
                ctx.moveTo(x, 50);
                ctx.lineTo(x, height - 50);
                ctx.stroke();
            }
            for (let i = 0; i <= 6; i++) {
                const y = 50 + i * (height - 100) / 6;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 30, y);
                ctx.stroke();
            }
            
            // 绘制需求曲线
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let p = 0; p <= 100; p += 1) {
                const q = elasticity.demand(p);
                if (q >= 0) {
                    const x = 50 + q * (width - 80) / 200;
                    const y = height - 50 - p * (height - 100) / 100;
                    if (p === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            ctx.stroke();
            
            // 绘制图例
            ctx.fillStyle = '#2563eb';
            ctx.fillRect(30, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('需求曲线', 50, 30);
            
            // 显示当前弹性类型
            ctx.fillStyle = '#000';
            ctx.font = '14px Arial';
            ctx.fillText(elasticity.name, width - 100, 30);
            ctx.fillText(elasticity.elasticity, width - 100, 50);
        }
        
        // 弹性控制按钮
        document.getElementById('prevElasticity').addEventListener('click', function() {
            currentElasticityIndex = (currentElasticityIndex - 1 + elasticityTypes.length) % elasticityTypes.length;
            drawElasticity();
        });
        
        document.getElementById('nextElasticity').addEventListener('click', function() {
            currentElasticityIndex = (currentElasticityIndex + 1) % elasticityTypes.length;
            drawElasticity();
        });
        
        // 消费者剩余与生产者剩余画布
        const surplusCtx = document.getElementById('surplusCanvas').getContext('2d');
        
        function drawSurplus() {
            const canvas = document.getElementById('surplusCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.parentElement.clientWidth;
            const height = canvas.height = canvas.parentElement.clientHeight;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(50, height - 50);
            ctx.lineTo(width - 30, height - 50);
            ctx.stroke();
            
            // 绘制网格
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 50 + i * (width - 80) / 10;
                ctx.beginPath();
                ctx.moveTo(x, 50);
                ctx.lineTo(x, height - 50);
                ctx.stroke();
            }
            for (let i = 0; i <= 6; i++) {
                const y = 50 + i * (height - 100) / 6;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 30, y);
                ctx.stroke();
            }
            
            // 计算均衡点
            const qEquilibrium = 60; // 均衡数量
            const pEquilibrium = 40; // 均衡价格
            
            // 绘制需求曲线
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let q = 0; q <= 100; q += 1) {
                const p = 100 - q; // 需求函数 P = 100 - Q
                const x = 50 + q * (width - 80) / 100;
                const y = height - 50 - p * (height - 100) / 100;
                if (q === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制供给曲线
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let q = 0; q <= 100; q += 1) {
                const p = q / 3; // 供给函数 P = Q/3
                const x = 50 + q * (width - 80) / 100;
                const y = height - 50 - p * (height - 100) / 100;
                if (q === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 计算并绘制消费者剩余（三角形区域）
            const xEquilibrium = 50 + qEquilibrium * (width - 80) / 100;
            const yEquilibrium = height - 50 - pEquilibrium * (height - 100) / 100;
            const yIntercept = height - 50 - 100 * (height - 100) / 100;
            
            ctx.fillStyle = 'rgba(37, 99, 235, 0.3)';
            ctx.beginPath();
            ctx.moveTo(50, yIntercept);
            ctx.lineTo(xEquilibrium, yEquilibrium);
            ctx.lineTo(50, yEquilibrium);
            ctx.closePath();
            ctx.fill();
            
            // 计算并绘制生产者剩余（三角形区域）
            ctx.fillStyle = 'rgba(124, 58, 237, 0.3)';
            ctx.beginPath();
            ctx.moveTo(50, height - 50);
            ctx.lineTo(xEquilibrium, height - 50);
            ctx.lineTo(xEquilibrium, yEquilibrium);
            ctx.closePath();
            ctx.fill();
            
            // 标记均衡点
            ctx.fillStyle = '#2563eb';
            ctx.beginPath();
            ctx.arc(xEquilibrium, yEquilibrium, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制图例
            ctx.fillStyle = '#2563eb';
            ctx.fillRect(30, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('需求曲线', 50, 30);
            
            ctx.fillStyle = '#f97316';
            ctx.fillRect(150, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('供给曲线', 170, 30);
        }
        
        // 最优化画布
        const optimizationCtx = document.getElementById('optimizationCanvas').getContext('2d');
        let budget = 100;
        const priceX = 10;
        const priceY = 5;
        
        function drawOptimization() {
            const canvas = document.getElementById('optimizationCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.parentElement.clientWidth;
            const height = canvas.height = canvas.parentElement.clientHeight;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(50, height - 50);
            ctx.lineTo(width - 30, height - 50);
            ctx.stroke();
            
            // 绘制网格
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 50 + i * (width - 80) / 10;
                ctx.beginPath();
                ctx.moveTo(x, 50);
                ctx.lineTo(x, height - 50);
                ctx.stroke();
            }
            for (let i = 0; i <= 6; i++) {
                const y = 50 + i * (height - 100) / 6;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 30, y);
                ctx.stroke();
            }
            
            // 绘制预算线
            const maxX = budget / priceX;
            const maxY = budget / priceY;
            
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const x1 = 50;
            const y1 = height - 50 - maxY * (height - 100) / (maxY + 10);
            const x2 = 50 + maxX * (width - 80) / (maxX + 5);
            const y2 = height - 50;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // 绘制几条无差异曲线
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 1;
            
            // 绘制多条无差异曲线
            for (let utility = 10; utility <= 50; utility += 10) {
                ctx.beginPath();
                let isFirstPoint = true;
                
                for (let x = 1; x <= maxX; x += 0.1) {
                    // 假设效用函数是柯布-道格拉斯形式：U(x,y) = x^0.5 * y^0.5
                    // 解出y = (utility^2)/x
                    const y = (utility * utility) / x;
                    
                    if (y <= maxY + 5) { // 确保在图中可见
                        const canvasX = 50 + x * (width - 80) / (maxX + 5);
                        const canvasY = height - 50 - y * (height - 100) / (maxY + 10);
                        
                        if (isFirstPoint) {
                            ctx.moveTo(canvasX, canvasY);
                            isFirstPoint = false;
                        } else {
                            ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                
                ctx.stroke();
            }
            
            // 找出预算线与无差异曲线的切点（效用最大化点）
            // 根据最优条件：MUx/MUy = Px/Py，对于U(x,y)=x^0.5*y^0.5，这个条件是 y/x = Px/Py
            // 结合预算约束：Px*x + Py*y = budget
            const optimalX = budget / (2 * priceX);
            const optimalY = budget / (2 * priceY);
            
            // 绘制最优点
            const optimalCanvasX = 50 + optimalX * (width - 80) / (maxX + 5);
            const optimalCanvasY = height - 50 - optimalY * (height - 100) / (maxY + 10);
            
            ctx.fillStyle = '#f97316';
            ctx.beginPath();
            ctx.arc(optimalCanvasX, optimalCanvasY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制连接到坐标轴的虚线
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(optimalCanvasX, optimalCanvasY);
            ctx.lineTo(optimalCanvasX, height - 50);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(optimalCanvasX, optimalCanvasY);
            ctx.lineTo(50, optimalCanvasY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // 改变预算按钮
        document.getElementById('changeBudget').addEventListener('click', function() {
            // 随机改变预算
            budget = 80 + Math.random() * 40;
            drawOptimization();
        });
        
        // 增长模型画布
        const growthModelCtx = document.getElementById('growthModelCanvas').getContext('2d');
        let savingRate = 0.2;
        
        function drawGrowthModel() {
            const canvas = document.getElementById('growthModelCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.parentElement.clientWidth;
            const height = canvas.height = canvas.parentElement.clientHeight;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(50, height - 50);
            ctx.lineTo(width - 30, height - 50);
            ctx.stroke();
            
            // 绘制网格
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 50 + i * (width - 80) / 10;
                ctx.beginPath();
                ctx.moveTo(x, 50);
                ctx.lineTo(x, height - 50);
                ctx.stroke();
            }
            for (let i = 0; i <= 6; i++) {
                const y = 50 + i * (height - 100) / 6;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 30, y);
                ctx.stroke();
            }
            
            // 假设生产函数是柯布-道格拉斯形式：f(k) = k^α，这里α=0.5
            const alpha = 0.5;
            const n = 0.02; // 人口增长率
            const delta = 0.03; // 折旧率
            const g = 0.01; // 技术进步率
            const breakEvenRate = n + delta + g;
            
            // 绘制人均产出曲线 f(k)
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let k = 0; k <= 100; k += 1) {
                const x = 50 + k * (width - 80) / 100;
                const output = Math.pow(k, alpha);
                const y = height - 50 - output * (height - 100) / 10;
                if (k === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制储蓄曲线 s·f(k)
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let k = 0; k <= 100; k += 1) {
                const x = 50 + k * (width - 80) / 100;
                const saving = savingRate * Math.pow(k, alpha);
                const y = height - 50 - saving * (height - 100) / 10;
                if (k === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制持平投资线 (n+δ+g)·k
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let k = 0; k <= 100; k += 1) {
                const x = 50 + k * (width - 80) / 100;
                const breakEvenInvestment = breakEvenRate * k;
                const y = height - 50 - breakEvenInvestment * (height - 100) / 10;
                if (k === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 找出稳态资本水平k*
            // 解方程：s·k^α = (n+δ+g)·k
            // 解得：k* = (s/(n+δ+g))^(1/(1-α))
            const steadyStateK = Math.pow(savingRate / breakEvenRate, 1 / (1 - alpha));
            const steadyStateOutput = Math.pow(steadyStateK, alpha);
            
            // 绘制稳态点
            const xSteadyState = 50 + steadyStateK * (width - 80) / 100;
            const ySteadyState = height - 50 - savingRate * steadyStateOutput * (height - 100) / 10;
            
            ctx.fillStyle = '#2563eb';
            ctx.beginPath();
            ctx.arc(xSteadyState, ySteadyState, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制连接到坐标轴的虚线
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(xSteadyState, ySteadyState);
            ctx.lineTo(xSteadyState, height - 50);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制图例
            ctx.fillStyle = '#2563eb';
            ctx.fillRect(30, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('人均产出 f(k)', 50, 30);
            
            ctx.fillStyle = '#7c3aed';
            ctx.fillRect(180, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('储蓄 s·f(k)', 200, 30);
            
            ctx.fillStyle = '#f97316';
            ctx.fillRect(300, 20, 15, 10);
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('持平投资 (n+δ+g)·k', 320, 30);
            
            // 更新储蓄率显示
            document.getElementById('savingRateValue').textContent = `储蓄率: ${Math.round(savingRate * 100)}%`;
        }
        
        // 储蓄率控制按钮
        document.getElementById('decreaseSaving').addEventListener('click', function() {
            if (savingRate > 0.1) {
                savingRate -= 0.01;
                drawGrowthModel();
            }
        });
        
        document.getElementById('increaseSaving').addEventListener('click', function() {
            if (savingRate < 0.4) {
                savingRate += 0.01;
                drawGrowthModel();
            }
        });
        
        // 初始化并绘制所有图表
        window.addEventListener('load', function() {
            drawMarginalAnalysis();
            drawElasticity();
            drawSurplus();
            drawOptimization();
            drawGrowthModel();
            
            // 添加窗口大小变化时重绘图表
            window.addEventListener('resize', function() {
                drawMarginalAnalysis();
                drawElasticity();
                drawSurplus();
                drawOptimization();
                drawGrowthModel();
            });
        });
    </script>
</body>
</html>