<html lang="zh-CN"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>微积分直观理解 | 从基础到应用</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- 引入Chart.js用于数据可视化 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    
    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#2563eb',
                        secondary: '#7c3aed',
                        accent: '#f97316',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        math: ['STIX Two Math', 'serif']
                    }
                }
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .canvas-container {
                @apply relative bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg;
            }
            .section-fade {
                @apply opacity-0 translate-y-8 transition-all duration-700;
            }
            .section-visible {
                @apply opacity-100 translate-y-0;
            }
        }
    </style>
    
    <style>
        /* 基础样式 */
        html {
            scroll-behavior: smooth;
        }
        
        body {
            background-color: #f8fafc;
        }
        
        /* 数学符号显示优化 */
        .math-expression {
            font-family: 'STIX Two Math', serif;
            font-size: 1.1em;
        }
        
        /* Canvas容器样式 */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* 滚动条样式优化 */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
    </style>
</head>

<body class="font-sans text-dark">
    <!-- 导航栏 -->
    <header id="navbar" class="fixed w-full z-50 transition-all duration-300 bg-white/90 backdrop-blur-sm shadow-sm">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-calculator text-primary text-2xl"></i>
                <h1 class="text-xl md:text-2xl font-bold text-primary">微积分直观理解</h1>
            </div>
            
            <!-- 桌面导航 -->
            <nav class="hidden md:flex space-x-8">
                <a href="#intro" class="text-dark/80 hover:text-primary transition-colors">简介</a>
                <a href="#derivative" class="text-dark/80 hover:text-primary transition-colors">导数</a>
                <a href="#integral" class="text-dark/80 hover:text-primary transition-colors">积分</a>
                <a href="#theorem" class="text-dark/80 hover:text-primary transition-colors">微积分基本定理</a>
                <a href="#applications" class="text-dark/80 hover:text-primary transition-colors">应用</a>
            </nav>
            
            <!-- 移动端菜单按钮 -->
            <button id="menu-toggle" class="md:hidden text-dark text-xl">
                <i class="fa fa-bars"></i>
            </button>
        </div>
        
        <!-- 移动端导航菜单 -->
        <div id="mobile-menu" class="hidden md:hidden bg-white border-t">
            <div class="container mx-auto px-4 py-2 flex flex-col space-y-3">
                <a href="#intro" class="py-2 text-dark/80 hover:text-primary transition-colors">简介</a>
                <a href="#derivative" class="py-2 text-dark/80 hover:text-primary transition-colors">导数</a>
                <a href="#integral" class="py-2 text-dark/80 hover:text-primary transition-colors">积分</a>
                <a href="#theorem" class="py-2 text-dark/80 hover:text-primary transition-colors">微积分基本定理</a>
                <a href="#applications" class="py-2 text-dark/80 hover:text-primary transition-colors">应用</a>
            </div>
        </div>
    </header>

    <!-- 英雄区域 -->
    <section class="pt-24 pb-16 md:pt-32 md:pb-24 bg-gradient-to-br from-primary/5 to-secondary/5">
        <div class="container mx-auto px-4">
            <div class="max-w-4xl mx-auto text-center">
                <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold mb-6 text-dark text-shadow">
                    探索微积分的<span class="text-primary">奇妙世界</span>
                </h1>
                <p class="text-lg md:text-xl text-dark/70 mb-10">
                    通过交互式可视化，直观理解微积分的核心概念、原理和应用
                </p>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <a href="#derivative" class="px-8 py-3 bg-primary text-white rounded-lg font-medium hover:bg-primary/90 transition-all shadow-md hover:shadow-lg transform hover:-translate-y-1">
                        开始学习 <i class="fa fa-arrow-right ml-2"></i>
                    </a>
                    <a href="#applications" class="px-8 py-3 bg-white text-primary border border-primary rounded-lg font-medium hover:bg-primary/5 transition-all">
                        查看应用案例
                    </a>
                </div>
            </div>
        </div>
    </section>

    <main class="container mx-auto px-4 py-12">
        <!-- 简介部分 -->
        <section id="intro" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-primary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">什么是微积分？</h2>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center">
                <div>
                    <p class="text-lg mb-4">
                        微积分是数学的一个分支，主要研究变化率和积累。它由艾萨克·牛顿和戈特弗里德·威廉·莱布尼茨在17世纪独立发展出来，是现代科学和工程学的基础。
                    </p>
                    <p class="text-lg mb-4">
                        微积分分为两个主要部分：
                    </p>
                    <ul class="space-y-2 mb-6">
                        <li class="flex items-start">
                            <i class="fa fa-arrow-right text-primary mt-1 mr-2"></i>
                            <span><strong>微分学</strong>：研究变化率，核心概念是导数</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-arrow-right text-primary mt-1 mr-2"></i>
                            <span><strong>积分学</strong>：研究积累，核心概念是积分</span>
                        </li>
                    </ul>
                    <p class="text-lg">
                        这两个分支通过"微积分基本定理"联系在一起，该定理揭示了导数和积分之间的逆运算关系。
                    </p>
                </div>
                
                <div class="canvas-container h-80">
                    <canvas id="introCanvas"></canvas>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        微积分：变化与积累的数学
                    </div>
                </div>
            </div>
        </section>

        <!-- 导数部分 -->
        <section id="derivative" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-primary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">导数：变化率的度量</h2>
            </div>
            
            <div class="mb-10">
                <p class="text-lg mb-4">
                    导数描述了函数在某一点的瞬时变化率。从几何角度看，函数在某点的导数就是该点切线的斜率。
                </p>
                <p class="text-lg mb-6">
                    对于函数 <span class="math-expression">f(x)</span>，其在点 <span class="math-expression">x</span> 处的导数定义为：
                </p>
                <div class="bg-white p-4 rounded-lg shadow-sm mb-6 text-center">
                    <span class="math-expression text-xl">f'(x) = lim<sub>h→0</sub> [f(x+h) - f(x)] / h</span>
                </div>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div class="canvas-container h-96">
                    <canvas id="derivativeCanvas"></canvas>
                    <div class="absolute top-3 right-3 flex space-x-2">
                        <button id="prevFunc" class="p-2 bg-primary/10 hover:bg-primary/20 rounded-full transition-colors">
                            <i class="fa fa-arrow-left text-primary"></i>
                        </button>
                        <button id="nextFunc" class="p-2 bg-primary/10 hover:bg-primary/20 rounded-full transition-colors">
                            <i class="fa fa-arrow-right text-primary"></i>
                        </button>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        拖动红点观察切线变化
                    </div>
                </div>
                
                <div>
                    <h3 class="text-2xl font-semibold mb-4">导数的直观理解</h3>
                    <p class="mb-4">
                        想象你正在驾车，速度表显示的就是你位置函数的导数。它告诉你在每个瞬间，你的位置变化有多快。
                    </p>
                    <p class="mb-4">
                        导数的正负表示函数是增加还是减少：
                    </p>
                    <ul class="space-y-2 mb-6">
                        <li class="flex items-start">
                            <i class="fa fa-arrow-up text-green-500 mt-1 mr-2"></i>
                            <span>当 <span class="math-expression">f'(x) &gt; 0</span> 时，函数在该点递增</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-arrow-down text-red-500 mt-1 mr-2"></i>
                            <span>当 <span class="math-expression">f'(x) &lt; 0</span> 时，函数在该点递减</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-minus text-gray-500 mt-1 mr-2"></i>
                            <span>当 <span class="math-expression">f'(x) = 0</span> 时，函数在该点可能有极值</span>
                        </li>
                    </ul>
                </div>
            </div>
            
            <div class="bg-primary/5 p-6 rounded-lg border border-primary/20">
                <h3 class="text-xl font-semibold mb-3 flex items-center">
                    <i class="fa fa-lightbulb-o text-primary mr-2"></i>
                    常见函数的导数
                </h3>
                <div class="grid md:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">f(x) = c (常数)</span>
                        <span class="mx-2">→</span>
                        <span class="math-expression">f'(x) = 0</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">f(x) = x<sup>n</sup></span>
                        <span class="mx-2">→</span>
                        <span class="math-expression">f'(x) = nx<sup>n-1</sup></span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">f(x) = sin(x)</span>
                        <span class="mx-2">→</span>
                        <span class="math-expression">f'(x) = cos(x)</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">f(x) = e<sup>x</sup></span>
                        <span class="mx-2">→</span>
                        <span class="math-expression">f'(x) = e<sup>x</sup></span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">f(x) = ln(x)</span>
                        <span class="mx-2">→</span>
                        <span class="math-expression">f'(x) = 1/x</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">f(x) = cos(x)</span>
                        <span class="mx-2">→</span>
                        <span class="math-expression">f'(x) = -sin(x)</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 积分部分 -->
        <section id="integral" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-secondary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">积分：积累的总和</h2>
            </div>
            
            <div class="mb-10">
                <p class="text-lg mb-4">
                    积分是微积分的另一个核心概念，主要用于计算积累量。定积分可以计算函数曲线下的面积，而不定积分则是求导的逆运算。
                </p>
                <p class="text-lg mb-6">
                    函数 <span class="math-expression">f(x)</span> 在区间 <span class="math-expression">[a, b]</span> 上的定积分定义为：
                </p>
                <div class="bg-white p-4 rounded-lg shadow-sm mb-6 text-center">
                    <span class="math-expression text-xl">∫<sub>a</sub><sup>b</sup> f(x) dx = lim<sub>n→∞</sub> Σ<sub>i=1</sub><sup>n</sup> f(x<sub>i</sub>)Δx</span>
                </div>
            </div>
            
            <div class="grid md:grid-cols-2 gap-10 items-center mb-10">
                <div>
                    <h3 class="text-2xl font-semibold mb-4">积分的直观理解</h3>
                    <p class="mb-4">
                        想象你正在驾车，速度计显示的速度随时间变化。那么速度函数在一段时间内的积分，就是这段时间内行驶的总距离。
                    </p>
                    <p class="mb-4">
                        定积分的几何意义是函数曲线与x轴之间，在区间[a, b]内围成的面积：
                    </p>
                    <ul class="space-y-2 mb-6">
                        <li class="flex items-start">
                            <i class="fa fa-check-circle text-green-500 mt-1 mr-2"></i>
                            <span>x轴上方的面积为正</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-times-circle text-red-500 mt-1 mr-2"></i>
                            <span>x轴下方的面积为负</span>
                        </li>
                        <li class="flex items-start">
                            <i class="fa fa-calculator text-primary mt-1 mr-2"></i>
                            <span>定积分结果是净面积</span>
                        </li>
                    </ul>
                </div>
                
                <div class="canvas-container h-96">
                    <canvas id="integralCanvas"></canvas>
                    <div class="absolute top-3 left-3 flex flex-col space-y-2">
                        <div class="flex items-center space-x-2">
                            <button id="decreaseN" class="p-2 bg-secondary/10 hover:bg-secondary/20 rounded-full transition-colors">
                                <i class="fa fa-minus text-secondary"></i>
                            </button>
                            <span id="nValue" class="text-sm bg-white px-2 py-1 rounded shadow-sm">分割数: 5</span>
                            <button id="increaseN" class="p-2 bg-secondary/10 hover:bg-secondary/20 rounded-full transition-colors">
                                <i class="fa fa-plus text-secondary"></i>
                            </button>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm bg-white px-2 py-1 rounded shadow-sm">面积: <span id="areaValue">0</span></span>
                        </div>
                    </div>
                    <div class="absolute bottom-3 left-3 text-sm text-dark/60">
                        拖动滑块改变积分区间
                    </div>
                </div>
            </div>
            
            <div class="bg-secondary/5 p-6 rounded-lg border border-secondary/20">
                <h3 class="text-xl font-semibold mb-3 flex items-center">
                    <i class="fa fa-lightbulb-o text-secondary mr-2"></i>
                    常见函数的积分
                </h3>
                <div class="grid md:grid-cols-2 gap-4">
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">∫ c dx = cx + C</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">∫ x<sup>n</sup> dx = x<sup>n+1</sup>/(n+1) + C (n ≠ -1)</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">∫ sin(x) dx = -cos(x) + C</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">∫ e<sup>x</sup> dx = e<sup>x</sup> + C</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">∫ 1/x dx = ln|x| + C</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm">
                        <span class="math-expression">∫ cos(x) dx = sin(x) + C</span>
                    </div>
                </div>
                <p class="mt-4 text-sm text-dark/70">
                    其中 C 是积分常数
                </p>
            </div>
        </section>

        <!-- 微积分基本定理部分 -->
        <section id="theorem" class="max-w-5xl mx-auto mb-20 section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-accent rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">微积分基本定理</h2>
            </div>
            
            <div class="mb-10">
                <p class="text-lg mb-6">
                    微积分基本定理是连接微分学和积分学的桥梁，它揭示了导数和积分之间的逆运算关系。
                </p>
                
                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-accent mb-10">
                    <h3 class="text-xl font-semibold mb-4">微积分基本定理第一部分</h3>
                    <p class="mb-4">
                        如果 <span class="math-expression">f</span> 是区间 <span class="math-expression">[a, b]</span> 上的连续函数，定义函数 <span class="math-expression">F(x)</span> 为：
                    </p>
                    <div class="text-center mb-4">
                        <span class="math-expression text-xl">F(x) = ∫<sub>a</sub><sup>x</sup> f(t) dt</span>
                    </div>
                    <p>
                        则 <span class="math-expression">F(x)</span> 在 <span class="math-expression">(a, b)</span> 上可导，且 <span class="math-expression">F'(x) = f(x)</span>。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-accent mb-10">
                    <h3 class="text-xl font-semibold mb-4">微积分基本定理第二部分</h3>
                    <p class="mb-4">
                        如果 <span class="math-expression">f</span> 是区间 <span class="math-expression">[a, b]</span> 上的连续函数，且 <span class="math-expression">F</span> 是 <span class="math-expression">f</span> 的一个原函数（即 <span class="math-expression">F'(x) = f(x)</span>），则：
                    </p>
                    <div class="text-center">
                        <span class="math-expression text-xl">∫<sub>a</sub><sup>b</sup> f(x) dx = F(b) - F(a)</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container h-96 mb-10">
                <canvas id="fundamentalTheoremCanvas"></canvas>
                <div class="absolute top-3 left-3 text-sm bg-white/80 backdrop-blur-sm px-3 py-2 rounded shadow-sm">
                    <p class="font-medium mb-1">导数与积分的关系</p>
                    <p class="text-xs text-dark/70">蓝色: f(x)，红色: f(x)的积分，绿色: 积分的导数</p>
                </div>
            </div>
            
            <div class="bg-accent/5 p-6 rounded-lg border border-accent/20">
                <h3 class="text-xl font-semibold mb-3 flex items-center">
                    <i class="fa fa-lightbulb-o text-accent mr-2"></i>
                    为什么这个定理如此重要？
                </h3>
                <p class="mb-4">
                    微积分基本定理的重要性在于：
                </p>
                <ul class="space-y-2">
                    <li class="flex items-start">
                        <i class="fa fa-check-circle text-accent mt-1 mr-2"></i>
                        <span>它将求面积（积分）的问题转化为求原函数的问题</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fa fa-check-circle text-accent mt-1 mr-2"></i>
                        <span>它建立了变化率（导数）和积累（积分）之间的深刻联系</span>
                    </li>
                    <li class="flex items-start">
                        <i class="fa fa-check-circle text-accent mt-1 mr-2"></i>
                        <span>它为解决实际问题提供了强大的工具，从物理学到经济学</span>
                    </li>
                </ul>
            </div>
        </section>

        <!-- 应用部分 -->
        <section id="applications" class="max-w-5xl mx-auto section-fade">
            <div class="flex items-center mb-8">
                <div class="w-12 h-1 bg-primary rounded-full mr-4"></div>
                <h2 class="text-3xl font-bold">微积分的实际应用</h2>
            </div>
            
            <p class="text-lg mb-10 text-center max-w-3xl mx-auto">
                微积分不仅仅是一门理论数学，它在科学、工程、经济等众多领域都有广泛的应用。
                以下是一些常见的应用场景：
            </p>
            
            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 mb-10">
                <!-- 物理应用 -->
                <a href="physics-applications.html" class="block bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg hover:-translate-y-1">
                    <div class="h-48 bg-primary/10 flex items-center justify-center">
                        <canvas id="physicsCanvas" class="w-full h-full"></canvas>
                    </div>
                    <div class="p-5">
                        <h3 class="text-xl font-semibold mb-2 flex items-center text-primary hover:text-primary/80">
                            <i class="fa fa-rocket text-primary mr-2"></i>
                            物理学
                        </h3>
                        <p class="text-dark/70">
                            微积分用于描述运动规律，计算加速度、速度和位移的关系，以及解决力学、电磁学等领域的问题。
                        </p>
                    </div>
                </a>
                
                <!-- 经济学应用 -->
                <a href="economics-applications.html" class="block bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg hover:-translate-y-1">
                    <div class="h-48 bg-secondary/10 flex items-center justify-center">
                        <canvas id="economicsCanvas" class="w-full h-full"></canvas>
                    </div>
                    <div class="p-5">
                        <h3 class="text-xl font-semibold mb-2 flex items-center text-primary hover:text-primary/80">
                            <i class="fa fa-line-chart text-secondary mr-2"></i>
                            经济学
                        </h3>
                        <p class="text-dark/70">
                            在经济学中，边际成本和边际收益通过导数计算，消费者剩余和生产者剩余通过积分计算。
                        </p>
                    </div>
                </a>
                
                <!-- 工程学应用 -->
                <a href="engineering-applications.html" class="block bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 hover:shadow-lg hover:-translate-y-1">
                    <div class="h-48 bg-accent/10 flex items-center justify-center">
                        <canvas id="engineeringCanvas" class="w-full h-full"></canvas>
                    </div>
                    <div class="p-5">
                        <h3 class="text-xl font-semibold mb-2 flex items-center text-primary hover:text-primary/80">
                            <i class="fa fa-cogs text-accent mr-2"></i>
                            工程学
                        </h3>
                        <p class="text-dark/70">
                            工程师使用微积分设计控制系统、分析结构稳定性、计算电路中的电流和电压变化等。
                        </p>
                    </div>
                </a>
            </div>
            
            <div class="bg-primary/5 p-6 rounded-lg border border-primary/20">
                <h3 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fa fa-lightbulb-o text-primary mr-2"></i>
                    微积分在日常生活中的应用
                </h3>
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <a href="weather-forecasting.html" class="block font-medium mb-2 text-primary hover:text-primary/80 transition-colors">
                            <h4>天气预报 <i class="fa fa-external-link ml-1 text-sm"></i></h4>
                        </a>
                        <p class="text-dark/70 mb-4">
                            气象学家使用微积分建立天气模型，预测温度、气压和风速的变化。<a href="weather-forecasting.html" class="text-primary hover:underline">查看详细内容</a>
                        </p>
                        
                        <a href="medical-imaging.html" class="block font-medium mb-2 text-primary hover:text-primary/80 transition-colors">
                            <h4>医学成像 <i class="fa fa-external-link ml-1 text-sm"></i></h4>
                        </a>
                        <p class="text-dark/70">
                            CT扫描和MRI技术利用微积分算法重建身体内部的三维图像。<a href="medical-imaging.html" class="text-primary hover:underline">查看详细内容</a>
                        </p>
                    </div>
                    <div>
                        <a href="traffic-flow-analysis.html" class="block font-medium mb-2 text-primary hover:text-primary/80 transition-colors">
                            <h4>交通流量分析 <i class="fa fa-external-link ml-1 text-sm"></i></h4>
                        </a>
                        <p class="text-dark/70 mb-4">
                            交通工程师使用微积分模型分析和预测交通流量，优化交通信号。<a href="traffic-flow-analysis.html" class="text-primary hover:underline">查看详细内容</a>
                        </p>
                        
                        <a href="computer-graphics.html" class="block font-medium mb-2 text-primary hover:text-primary/80 transition-colors">
                            <h4>计算机图形学 <i class="fa fa-external-link ml-1 text-sm"></i></h4>
                        </a>
                        <p class="text-dark/70">
                            动画和游戏中的曲线、曲面和运动效果都是通过微积分计算实现的。<a href="computer-graphics.html" class="text-primary hover:underline">查看详细内容</a>
                        </p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-12">
        <div class="container mx-auto px-4">
            <div class="max-w-5xl mx-auto">
                <div class="flex flex-col md:flex-row justify-between items-center mb-8">
                    <div class="flex items-center space-x-2 mb-4 md:mb-0">
                        <i class="fa fa-calculator text-primary text-2xl"></i>
                        <h2 class="text-xl font-bold">微积分直观理解</h2>
                    </div>
                    <div class="flex space-x-6">
                        <a href="#intro" class="text-white/70 hover:text-primary transition-colors">简介</a>
                        <a href="#derivative" class="text-white/70 hover:text-primary transition-colors">导数</a>
                        <a href="#integral" class="text-white/70 hover:text-primary transition-colors">积分</a>
                        <a href="#applications" class="text-white/70 hover:text-primary transition-colors">应用</a>
                    </div>
                </div>
                
                <div class="border-t border-white/10 pt-8 text-center text-white/60 text-sm">
                    <p>© 2023 微积分直观理解. 本网站旨在通过交互式可视化帮助理解微积分概念。</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- JavaScript代码 -->
    <script>
        // 导航栏滚动效果
        window.addEventListener('scroll', function() {
            const navbar = document.getElementById('navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('py-2', 'shadow');
                navbar.classList.remove('py-3');
            } else {
                navbar.classList.add('py-3');
                navbar.classList.remove('py-2', 'shadow');
            }
        });
        
        // 移动端菜单切换
        document.getElementById('menu-toggle').addEventListener('click', function() {
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenu.classList.toggle('hidden');
        });
        
        // 点击移动端菜单项后关闭菜单
        document.querySelectorAll('#mobile-menu a').forEach(link => {
            link.addEventListener('click', function() {
                document.getElementById('mobile-menu').classList.add('hidden');
            });
        });
        
        // 滚动动画
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.1
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('section-visible');
                    observer.unobserve(entry.target);
                }
            });
        }, observerOptions);
        
        document.querySelectorAll('.section-fade').forEach(section => {
            observer.observe(section);
        });
        
        // 简介部分的Canvas
        function initIntroCanvas() {
            const canvas = document.getElementById('introCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawIntro();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            function drawIntro() {
                const w = canvas.width;
                const h = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制坐标轴
                ctx.beginPath();
                ctx.moveTo(w * 0.1, h * 0.5);
                ctx.lineTo(w * 0.9, h * 0.5);
                ctx.moveTo(w * 0.5, h * 0.1);
                ctx.lineTo(w * 0.5, h * 0.9);
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // 绘制导数相关的图形 - 一条曲线和切线
                ctx.beginPath();
                const dx = (w * 0.7) / 100;
                let x, y;
                
                // 曲线
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                for (let i = 0; i <= 100; i++) {
                    x = w * 0.15 + i * dx;
                    // 简单的二次函数
                    y = h * 0.5 - Math.pow(i - 50, 2) * 0.02;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 切线
                const tangentPointX = w * 0.4;
                const tangentPointY = h * 0.5 - Math.pow(30 - 50, 2) * 0.02;
                ctx.beginPath();
                ctx.moveTo(tangentPointX - 50, tangentPointY + 20);
                ctx.lineTo(tangentPointX + 50, tangentPointY - 20);
                ctx.strokeStyle = '#f97316';
                ctx.setLineDash([5, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 标记点
                ctx.beginPath();
                ctx.arc(tangentPointX, tangentPointY, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#f97316';
                ctx.fill();
                
                // 绘制积分相关的图形 - 曲线下方面积
                ctx.beginPath();
                ctx.strokeStyle = '#7c3aed';
                ctx.lineWidth = 2;
                
                // 曲线
                for (let i = 0; i <= 100; i++) {
                    x = w * 0.55 + i * dx * 0.5;
                    // 简单的正弦曲线
                    y = h * 0.5 - Math.sin(i * 0.1) * 50;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 填充面积
                ctx.lineTo(w * 0.55 + 100 * dx * 0.5, h * 0.5);
                ctx.lineTo(w * 0.55, h * 0.5);
                ctx.closePath();
                ctx.fillStyle = 'rgba(124, 58, 237, 0.2)';
                ctx.fill();
                
                // 文字说明
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('导数: 变化率', w * 0.3, h * 0.2);
                ctx.fillText('积分: 积累', w * 0.75, h * 0.2);
            }
        }
        
        // 导数部分的Canvas
        function initDerivativeCanvas() {
            const canvas = document.getElementById('derivativeCanvas');
            const ctx = canvas.getContext('2d');
            
            // 函数列表
            const functions = [
                {
                    f: x => x * x,
                    fPrime: x => 2 * x,
                    name: 'f(x) = x²'
                },
                {
                    f: x => Math.sin(x) * 50 + 100,
                    fPrime: x => Math.cos(x) * 0.5,
                    name: 'f(x) = sin(x)'
                },
                {
                    f: x => Math.exp(x / 50) * 20,
                    fPrime: x => Math.exp(x / 50) * 0.4,
                    name: 'f(x) = eˣ'
                }
            ];
            
            let currentFuncIndex = 0;
            let currentX = 0;
            let isDragging = false;
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                currentX = -canvas.width / 4; // 初始x位置
                drawDerivative();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // 切换函数
            document.getElementById('prevFunc').addEventListener('click', () => {
                currentFuncIndex = (currentFuncIndex - 1 + functions.length) % functions.length;
                drawDerivative();
            });
            
            document.getElementById('nextFunc').addEventListener('click', () => {
                currentFuncIndex = (currentFuncIndex + 1) % functions.length;
                drawDerivative();
            });
            
            // 鼠标事件
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 检查是否点击了红点
                const pointX = mapXToDomain(x);
                const distance = Math.hypot(pointX - currentX, 0);
                if (distance < 10) {
                    isDragging = true;
                    currentX = pointX;
                    drawDerivative();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    currentX = mapXToDomain(x);
                    drawDerivative();
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // 触摸事件
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.touches[0].clientX - rect.left;
                
                currentX = mapXToDomain(x);
                isDragging = true;
                drawDerivative();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    currentX = mapXToDomain(x);
                    drawDerivative();
                }
            });
            
            window.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            // 坐标转换函数
            function mapXToDomain(screenX) {
                const rect = canvas.getBoundingClientRect();
                return (screenX / rect.width) * 200 - 100; // 将屏幕X映射到[-100, 100]
            }
            
            function mapXToScreen(domainX) {
                const rect = canvas.getBoundingClientRect();
                return ((domainX + 100) / 200) * rect.width;
            }
            
            function mapYToScreen(domainY) {
                const rect = canvas.getBoundingClientRect();
                return rect.height - ((domainY) / 200) * rect.height; // 反转Y轴
            }
            
            function drawDerivative() {
                const w = canvas.width;
                const h = canvas.height;
                const currentFunc = functions[currentFuncIndex];
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制网格
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // 水平线
                for (let i = 0; i < 5; i++) {
                    const y = h * 0.1 + i * h * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(w * 0.1, y);
                    ctx.lineTo(w * 0.9, y);
                    ctx.stroke();
                }
                
                // 垂直线
                for (let i = 0; i < 5; i++) {
                    const x = w * 0.1 + i * w * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(x, h * 0.1);
                    ctx.lineTo(x, h * 0.9);
                    ctx.stroke();
                }
                
                // 绘制坐标轴
                ctx.beginPath();
                ctx.moveTo(w * 0.1, h * 0.5);
                ctx.lineTo(w * 0.9, h * 0.5);
                ctx.moveTo(w * 0.5, h * 0.1);
                ctx.lineTo(w * 0.5, h * 0.9);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 绘制函数曲线
                ctx.beginPath();
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                
                const step = 2;
                for (let x = -100; x <= 100; x += step) {
                    const y = currentFunc.f(x);
                    const screenX = mapXToScreen(x);
                    const screenY = mapYToScreen(y);
                    
                    if (x === -100) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.stroke();
                
                // 计算当前点的函数值和导数值
                const currentY = currentFunc.f(currentX);
                const derivative = currentFunc.fPrime(currentX);
                
                // 绘制切线
                const tangentLength = 50;
                const x1 = currentX - tangentLength;
                const y1 = currentY - derivative * tangentLength;
                const x2 = currentX + tangentLength;
                const y2 = currentY + derivative * tangentLength;
                
                ctx.beginPath();
                ctx.moveTo(mapXToScreen(x1), mapYToScreen(y1));
                ctx.lineTo(mapXToScreen(x2), mapYToScreen(y2));
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制当前点
                ctx.beginPath();
                ctx.arc(mapXToScreen(currentX), mapYToScreen(currentY), 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 显示函数名称
                ctx.fillStyle = '#1e293b';
                ctx.font = '16px Inter, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(currentFunc.name, w * 0.1, h * 0.15);
                
                // 显示当前点的导数信息
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`在 x = ${currentX.toFixed(1)} 处`, w * 0.1, h * 0.85);
                ctx.fillText(`导数 = ${derivative.toFixed(2)}`, w * 0.1, h * 0.9);
                ctx.fillText(`(切线斜率)`, w * 0.1, h * 0.95);
            }
        }
        
        // 积分部分的Canvas
        function initIntegralCanvas() {
            const canvas = document.getElementById('integralCanvas');
            const ctx = canvas.getContext('2d');
            
            let n = 5; // 矩形数量
            let a = -60; // 积分下限
            let b = 60; // 积分上限
            let draggingPoint = null; // 'a' 或 'b' 或 null
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawIntegral();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // 调整矩形数量
            document.getElementById('decreaseN').addEventListener('click', () => {
                n = Math.max(1, n - 1);
                document.getElementById('nValue').textContent = `分割数: ${n}`;
                drawIntegral();
            });
            
            document.getElementById('increaseN').addEventListener('click', () => {
                n = Math.min(50, n + 1);
                document.getElementById('nValue').textContent = `分割数: ${n}`;
                drawIntegral();
            });
            
            // 鼠标事件
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 检查是否点击了a点
                const aScreenX = mapXToScreen(a);
                const distanceToA = Math.hypot(x - aScreenX, y - rect.height * 0.5);
                if (distanceToA < 10) {
                    draggingPoint = 'a';
                    return;
                }
                
                // 检查是否点击了b点
                const bScreenX = mapXToScreen(b);
                const distanceToB = Math.hypot(x - bScreenX, y - rect.height * 0.5);
                if (distanceToB < 10) {
                    draggingPoint = 'b';
                    return;
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (draggingPoint) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const domainX = mapXToDomain(x);
                    
                    // 限制在范围内
                    const minX = -80;
                    const maxX = 80;
                    
                    if (draggingPoint === 'a') {
                        a = Math.min(Math.max(domainX, minX), b - 10);
                    } else if (draggingPoint === 'b') {
                        b = Math.max(Math.min(domainX, maxX), a + 10);
                    }
                    
                    drawIntegral();
                }
            });
            
            window.addEventListener('mouseup', () => {
                draggingPoint = null;
            });
            
            // 触摸事件
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.touches[0].clientX - rect.left;
                
                // 检查是否点击了a点
                const aScreenX = mapXToScreen(a);
                const distanceToA = Math.hypot(x - aScreenX, rect.height * 0.5 - rect.height * 0.5);
                if (distanceToA < 10) {
                    draggingPoint = 'a';
                    return;
                }
                
                // 检查是否点击了b点
                const bScreenX = mapXToScreen(b);
                const distanceToB = Math.hypot(x - bScreenX, rect.height * 0.5 - rect.height * 0.5);
                if (distanceToB < 10) {
                    draggingPoint = 'b';
                    return;
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (draggingPoint) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    const domainX = mapXToDomain(x);
                    
                    // 限制在范围内
                    const minX = -80;
                    const maxX = 80;
                    
                    if (draggingPoint === 'a') {
                        a = Math.min(Math.max(domainX, minX), b - 10);
                    } else if (draggingPoint === 'b') {
                        b = Math.max(Math.min(domainX, maxX), a + 10);
                    }
                    
                    drawIntegral();
                }
            });
            
            window.addEventListener('touchend', () => {
                draggingPoint = null;
            });
            
            // 坐标转换函数
            function mapXToDomain(screenX) {
                const rect = canvas.getBoundingClientRect();
                return (screenX / rect.width) * 160 - 80; // 将屏幕X映射到[-80, 80]
            }
            
            function mapXToScreen(domainX) {
                const rect = canvas.getBoundingClientRect();
                return ((domainX + 80) / 160) * rect.width;
            }
            
            function mapYToScreen(domainY) {
                const rect = canvas.getBoundingClientRect();
                return rect.height * 0.5 - (domainY / 60) * rect.height * 0.35; // 映射Y值到屏幕
            }
            
            // 被积函数
            function f(x) {
                return Math.sin(x / 20) * 30 + Math.cos(x / 30) * 15;
            }
            
            function drawIntegral() {
                const w = canvas.width;
                const h = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制网格
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // 水平线
                for (let i = 0; i < 5; i++) {
                    const y = h * 0.1 + i * h * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(w * 0.1, y);
                    ctx.lineTo(w * 0.9, y);
                    ctx.stroke();
                }
                
                // 垂直线
                for (let i = 0; i < 5; i++) {
                    const x = w * 0.1 + i * w * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(x, h * 0.1);
                    ctx.lineTo(x, h * 0.9);
                    ctx.stroke();
                }
                
                // 绘制坐标轴
                ctx.beginPath();
                ctx.moveTo(w * 0.1, h * 0.5);
                ctx.lineTo(w * 0.9, h * 0.5);
                ctx.moveTo(w * 0.5, h * 0.1);
                ctx.lineTo(w * 0.5, h * 0.9);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 绘制函数曲线
                ctx.beginPath();
                ctx.strokeStyle = '#7c3aed';
                ctx.lineWidth = 2;
                
                const step = 1;
                for (let x = -80; x <= 80; x += step) {
                    const y = f(x);
                    const screenX = mapXToScreen(x);
                    const screenY = mapYToScreen(y);
                    
                    if (x === -80) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.stroke();
                
                // 绘制积分区间
                const dx = (b - a) / n;
                let totalArea = 0;
                
                // 绘制矩形
                for (let i = 0; i < n; i++) {
                    const x = a + i * dx;
                    const xMid = x + dx / 2; // 中点
                    const y = f(xMid);
                    const area = y * dx;
                    totalArea += area;
                    
                    // 矩形的屏幕坐标
                    const rectX = mapXToScreen(x);
                    const rectWidth = mapXToScreen(x + dx) - rectX;
                    const rectY = mapYToScreen(0);
                    const rectHeight = mapYToScreen(y) - rectY;
                    
                    // 绘制矩形
                    ctx.fillStyle = y > 0 ? 'rgba(124, 58, 237, 0.3)' : 'rgba(239, 68, 68, 0.3)';
                    ctx.fillRect(rectX, Math.min(rectY, rectY + rectHeight), rectWidth, Math.abs(rectHeight));
                    
                    // 矩形边框
                    ctx.strokeStyle = y > 0 ? 'rgba(124, 58, 237, 0.6)' : 'rgba(239, 68, 68, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(rectX, Math.min(rectY, rectY + rectHeight), rectWidth, Math.abs(rectHeight));
                }
                
                // 绘制积分区间的垂直线
                ctx.beginPath();
                ctx.moveTo(mapXToScreen(a), h * 0.1);
                ctx.lineTo(mapXToScreen(a), h * 0.9);
                ctx.moveTo(mapXToScreen(b), h * 0.1);
                ctx.lineTo(mapXToScreen(b), h * 0.9);
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 绘制区间端点
                // a点
                ctx.beginPath();
                ctx.arc(mapXToScreen(a), h * 0.5, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#f97316';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // b点
                ctx.beginPath();
                ctx.arc(mapXToScreen(b), h * 0.5, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#f97316';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 显示积分区间
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`积分区间: [${a.toFixed(0)}, ${b.toFixed(0)}]`, w * 0.6, h * 0.85);
                
                // 显示面积
                const areaDisplay = totalArea.toFixed(1);
                document.getElementById('areaValue').textContent = areaDisplay;
                
                // 显示积分符号
                ctx.font = '16px STIX Two Math, serif';
                ctx.textAlign = 'center';
                ctx.fillText(`∫f(x)dx ≈ ${areaDisplay}`, w * 0.8, h * 0.15);
            }
        }
        
        // 微积分基本定理部分的Canvas
        function initFundamentalTheoremCanvas() {
            const canvas = document.getElementById('fundamentalTheoremCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawFundamentalTheorem();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // 函数f(x)
            function f(x) {
                return Math.sin(x / 40) * 40;
            }
            
            // 计算积分F(x) = ∫₀ˣ f(t)dt
            function F(x) {
                let sum = 0;
                const steps = 100;
                const dx = x / steps;
                
                for (let i = 0; i < steps; i++) {
                    const t = i * dx;
                    sum += f(t) * dx;
                }
                
                return sum;
            }
            
            function drawFundamentalTheorem() {
                const w = canvas.width;
                const h = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制网格
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                
                // 水平线
                for (let i = 0; i < 5; i++) {
                    const y = h * 0.1 + i * h * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(w * 0.1, y);
                    ctx.lineTo(w * 0.9, y);
                    ctx.stroke();
                }
                
                // 垂直线
                for (let i = 0; i < 5; i++) {
                    const x = w * 0.1 + i * w * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(x, h * 0.1);
                    ctx.lineTo(x, h * 0.9);
                    ctx.stroke();
                }
                
                // 绘制坐标轴
                ctx.beginPath();
                ctx.moveTo(w * 0.1, h * 0.5);
                ctx.lineTo(w * 0.9, h * 0.5);
                ctx.moveTo(w * 0.5, h * 0.1);
                ctx.lineTo(w * 0.5, h * 0.9);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 坐标转换函数
                function mapXToDomain(screenX) {
                    return (screenX / w) * 200 - 100; // 将屏幕X映射到[-100, 100]
                }
                
                function mapXToScreen(domainX) {
                    return ((domainX + 100) / 200) * w;
                }
                
                function mapYToScreen1(domainY) {
                    // 用于f(x)和F'(x)的Y映射
                    return h * 0.5 - (domainY / 60) * h * 0.3;
                }
                
                function mapYToScreen2(domainY) {
                    // 用于F(x)的Y映射（缩放因子不同）
                    return h * 0.5 - (domainY / 200) * h * 0.3;
                }
                
                // 绘制f(x) - 蓝色
                ctx.beginPath();
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                
                for (let x = -100; x <= 100; x++) {
                    const y = f(x);
                    const screenX = mapXToScreen(x);
                    const screenY = mapYToScreen1(y);
                    
                    if (x === -100) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.stroke();
                
                // 绘制F(x) - 红色（积分）
                ctx.beginPath();
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                
                for (let x = -100; x <= 100; x++) {
                    const y = F(x);
                    const screenX = mapXToScreen(x);
                    const screenY = mapYToScreen2(y);
                    
                    if (x === -100) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.stroke();
                
                // 绘制F'(x) - 绿色（积分的导数）
                ctx.beginPath();
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                
                for (let x = -100; x <= 100; x++) {
                    // 数值微分近似F'(x)
                    const hStep = 1;
                    const derivative = (F(x + hStep) - F(x - hStep)) / (2 * hStep);
                    const screenX = mapXToScreen(x);
                    const screenY = mapYToScreen1(derivative);
                    
                    if (x === -100) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 填充f(x)下的区域作为积分的表示
                ctx.beginPath();
                for (let x = -80; x <= 80; x++) {
                    const y = f(x);
                    const screenX = mapXToScreen(x);
                    const screenY = mapYToScreen1(y);
                    
                    if (x === -80) {
                        ctx.moveTo(screenX, mapYToScreen1(0));
                        ctx.lineTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                ctx.lineTo(mapXToScreen(80), mapYToScreen1(0));
                ctx.closePath();
                ctx.fillStyle = 'rgba(37, 99, 235, 0.1)';
                ctx.fill();
                
                // 说明文字
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                
                // f(x)标签
                ctx.fillStyle = '#2563eb';
                ctx.fillText('f(x)', mapXToScreen(70), mapYToScreen1(f(70)) - 10);
                
                // F(x)标签
                ctx.fillStyle = '#ef4444';
                ctx.fillText('F(x) = ∫f(t)dt', mapXToScreen(70), mapYToScreen2(F(70)) - 10);
                
                // F'(x)标签
                ctx.fillStyle = '#22c55e';
                ctx.fillText('F\'(x)', mapXToScreen(70), mapYToScreen1((F(70 + 1) - F(70 - 1)) / 2) + 20);
                
                // 基本定理表达式
                ctx.font = '16px STIX Two Math, serif';
                ctx.fillStyle = '#1e293b';
                ctx.textAlign = 'center';
                ctx.fillText('d/dx [∫ₐˣ f(t)dt] = f(x)', w * 0.5, h * 0.15);
            }
        }
        
        // 物理应用Canvas
        function initPhysicsCanvas() {
            const canvas = document.getElementById('physicsCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawPhysics();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            function drawPhysics() {
                const w = canvas.width;
                const h = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制背景网格
                ctx.strokeStyle = 'rgba(37, 99, 235, 0.1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 5; i++) {
                    const x = w * 0.1 + i * w * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                for (let i = 0; i < 5; i++) {
                    const y = h * 0.1 + i * h * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // 绘制地面
                ctx.fillStyle = '#e2e8f0';
                ctx.fillRect(0, h * 0.8, w, h * 0.2);
                
                // 绘制抛物线轨迹
                ctx.beginPath();
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                
                for (let x = 0; x <= w; x += 5) {
                    // 抛物线方程 y = ax² + bx + c
                    const t = x / w;
                    const y = h * 0.8 - 300 * t * (1 - t);
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 绘制小球
                const ballX = w * 0.6;
                const ballY = h * 0.8 - 300 * 0.6 * (1 - 0.6);
                
                ctx.beginPath();
                ctx.arc(ballX, ballY, h * 0.05, 0, Math.PI * 2);
                ctx.fillStyle = '#2563eb';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制速度向量
                const vx = 30;
                const vy = -300 * (1 - 2 * 0.6); // 导数
                
                ctx.beginPath();
                ctx.moveTo(ballX, ballY);
                ctx.lineTo(ballX + vx, ballY + vy);
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制向量箭头
                const arrowAngle = Math.atan2(vy, vx);
                ctx.beginPath();
                ctx.moveTo(ballX + vx, ballY + vy);
                ctx.lineTo(
                    ballX + vx - 8 * Math.cos(arrowAngle - Math.PI / 6),
                    ballY + vy - 8 * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    ballX + vx - 8 * Math.cos(arrowAngle + Math.PI / 6),
                    ballY + vy - 8 * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = '#f97316';
                ctx.fill();
                
                // 文字说明
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('抛射体运动', w * 0.5, h * 0.1);
                ctx.fillText('速度向量', ballX + vx + 20, ballY + vy);
            }
        }
        
        // 经济学应用Canvas
        function initEconomicsCanvas() {
            const canvas = document.getElementById('economicsCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawEconomics();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            function drawEconomics() {
                const w = canvas.width;
                const h = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制背景网格
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 5; i++) {
                    const x = w * 0.1 + i * w * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                for (let i = 0; i < 5; i++) {
                    const y = h * 0.1 + i * h * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // 绘制坐标轴
                ctx.beginPath();
                ctx.moveTo(w * 0.15, h * 0.8);
                ctx.lineTo(w * 0.85, h * 0.8);
                ctx.moveTo(w * 0.15, h * 0.8);
                ctx.lineTo(w * 0.15, h * 0.2);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 绘制需求曲线
                ctx.beginPath();
                ctx.strokeStyle = '#7c3aed';
                ctx.lineWidth = 2;
                
                for (let x = w * 0.15; x <= w * 0.85; x += 5) {
                    const t = (x - w * 0.15) / (w * 0.7);
                    const y = h * 0.8 - t * h * 0.5;
                    
                    if (x === w * 0.15) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 绘制供给曲线
                ctx.beginPath();
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                
                for (let x = w * 0.15; x <= w * 0.85; x += 5) {
                    const t = (x - w * 0.15) / (w * 0.7);
                    const y = h * 0.3 + t * h * 0.4;
                    
                    if (x === w * 0.15) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 平衡点
                const eqX = w * 0.5;
                const eqY = h * 0.55;
                
                ctx.beginPath();
                ctx.arc(eqX, eqY, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#f97316';
                ctx.fill();
                
                // 消费者剩余（积分区域）
                ctx.beginPath();
                ctx.moveTo(w * 0.15, h * 0.3);
                for (let x = w * 0.15; x <= eqX; x += 5) {
                    const t = (x - w * 0.15) / (w * 0.7);
                    const y = h * 0.8 - t * h * 0.5;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(eqX, eqY);
                ctx.lineTo(w * 0.15, eqY);
                ctx.closePath();
                ctx.fillStyle = 'rgba(124, 58, 237, 0.2)';
                ctx.fill();
                
                // 文字说明
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('供需平衡与消费者剩余', w * 0.5, h * 0.1);
                
                ctx.textAlign = 'right';
                ctx.fillText('需求', w * 0.85, h * 0.3);
                
                ctx.textAlign = 'left';
                ctx.fillText('供给', w * 0.85, h * 0.7);
                
                ctx.fillStyle = '#7c3aed';
                ctx.textAlign = 'center';
                ctx.fillText('消费者剩余', w * 0.3, h * 0.4);
            }
        }
        
        // 工程学应用Canvas
        function initEngineeringCanvas() {
            const canvas = document.getElementById('engineeringCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawEngineering();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            function drawEngineering() {
                const w = canvas.width;
                const h = canvas.height;
                
                // 清空画布
                ctx.clearRect(0, 0, w, h);
                
                // 绘制背景网格
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 5; i++) {
                    const x = w * 0.1 + i * w * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                for (let i = 0; i < 5; i++) {
                    const y = h * 0.1 + i * h * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // 绘制梁
                ctx.fillStyle = '#94a3b8';
                ctx.fillRect(w * 0.1, h * 0.6, w * 0.8, h * 0.05);
                
                // 绘制支撑点
                ctx.fillStyle = '#64748b';
                ctx.fillRect(w * 0.1, h * 0.65, w * 0.05, h * 0.1);
                ctx.fillRect(w * 0.85, h * 0.65, w * 0.05, h * 0.1);
                
                // 绘制重物
                const weightX = w * 0.5;
                ctx.fillStyle = '#f97316';
                ctx.fillRect(weightX - w * 0.05, h * 0.5, w * 0.1, h * 0.1);
                
                // 绘制力箭头
                ctx.beginPath();
                ctx.moveTo(weightX, h * 0.5);
                ctx.lineTo(weightX, h * 0.3);
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 箭头
                ctx.beginPath();
                ctx.moveTo(weightX, h * 0.3);
                ctx.lineTo(weightX - 5, h * 0.35);
                ctx.lineTo(weightX + 5, h * 0.35);
                ctx.closePath();
                ctx.fillStyle = '#ef4444';
                ctx.fill();
                
                // 绘制挠度曲线（梁的弯曲）
                ctx.beginPath();
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                
                for (let x = w * 0.1; x <= w * 0.9; x += 5) {
                    const t = (x - w * 0.1) / (w * 0.8);
                    // 简单的挠度曲线
                    const deflection = Math.sin(t * Math.PI) * 20;
                    const y = h * 0.625 - deflection;
                    
                    if (x === w * 0.1) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 绘制应力分布曲线
                ctx.beginPath();
                ctx.strokeStyle = '#7c3aed';
                ctx.lineWidth = 2;
                
                for (let x = w * 0.1; x <= w * 0.9; x += 5) {
                    const t = (x - w * 0.1) / (w * 0.8);
                    // 应力与曲率相关，曲率是挠度的二阶导数
                    const stress = Math.sin(t * Math.PI) * 30;
                    const y = h * 0.2 + stress;
                    
                    if (x === w * 0.1) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 文字说明
                ctx.fillStyle = '#1e293b';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('梁的受力分析', w * 0.5, h * 0.1);
                ctx.fillText('挠度', w * 0.5, h * 0.6 - 30);
                ctx.fillText('应力', w * 0.5, h * 0.2);
            }
        }
        
        // 初始化所有Canvas
        window.addEventListener('load', () => {
            initIntroCanvas();
            initDerivativeCanvas();
            initIntegralCanvas();
            initFundamentalTheoremCanvas();
            initPhysicsCanvas();
            initEconomicsCanvas();
            initEngineeringCanvas();
        });
    </script>


</body></html>