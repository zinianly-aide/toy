<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>计算机图形学中的微积分应用 - 微积分教程</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    
    <!-- Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#1E40AF',  // 深蓝色
                        secondary: '#3B82F6', // 中蓝色
                        accent: '#9333EA',    // 紫色
                        light: '#EFF6FF',     // 浅蓝色背景
                        dark: '#1E293B',      // 深色文字
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        display: ['Montserrat', 'system-ui', 'sans-serif'],
                    },
                },
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .gradient-bg {
                background: linear-gradient(135deg, #1E40AF 0%, #3B82F6 100%);
            }
            .math-formula {
                font-family: 'Cambria Math', serif;
                font-style: italic;
            }
        }
    </style>
    
    <style>
        body {
            scroll-behavior: smooth;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%; /* 16:9 比例 */
            overflow: hidden;
        }
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* 导航栏滚动效果 */
        .navbar {
            transition: all 0.3s ease;
        }
        .navbar-scrolled {
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        /* 代码高亮 */
        .code-block {
            background-color: #f8fafc;
            border-left: 4px solid #3B82F6;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        /* 数学公式动画效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .formula-animation {
            animation: fadeIn 0.8s ease forwards;
        }
    </style>
</head>
<body class="font-sans text-dark bg-light">
    <!-- 导航栏 -->
    <nav id="navbar" class="navbar fixed w-full z-50 py-4 px-6 bg-white bg-opacity-80 backdrop-blur-md transition-all duration-300">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-calculator text-primary text-2xl"></i>
                <a href="calculus-tutorial.html" class="text-xl font-bold text-primary">微积分教程</a>
            </div>
            
            <!-- 桌面导航 -->
            <div class="hidden md:flex space-x-8">
                <a href="calculus-tutorial.html" class="text-dark hover:text-primary transition-colors">首页</a>
                <a href="calculus-tutorial.html#concepts" class="text-dark hover:text-primary transition-colors">基本概念</a>
                <a href="calculus-tutorial.html#applications" class="text-primary font-medium">应用案例</a>
                <a href="calculus-tutorial.html#exercises" class="text-dark hover:text-primary transition-colors">练习题</a>
                <a href="calculus-tutorial.html#resources" class="text-dark hover:text-primary transition-colors">学习资源</a>
            </div>
            
            <!-- 移动端菜单按钮 -->
            <button id="menu-toggle" class="md:hidden text-dark text-xl">
                <i class="fa fa-bars"></i>
            </button>
        </div>
        
        <!-- 移动端导航菜单 -->
        <div id="mobile-menu" class="md:hidden hidden bg-white w-full mt-4 py-4 px-6 absolute left-0 top-full shadow-lg">
            <div class="flex flex-col space-y-4">
                <a href="calculus-tutorial.html" class="text-dark hover:text-primary transition-colors">首页</a>
                <a href="calculus-tutorial.html#concepts" class="text-dark hover:text-primary transition-colors">基本概念</a>
                <a href="calculus-tutorial.html#applications" class="text-primary font-medium">应用案例</a>
                <a href="calculus-tutorial.html#exercises" class="text-dark hover:text-primary transition-colors">练习题</a>
                <a href="calculus-tutorial.html#resources" class="text-dark hover:text-primary transition-colors">学习资源</a>
            </div>
        </div>
    </nav>

    <!-- 英雄区域 -->
    <header class="relative pt-28 pb-16 px-6 md:pt-40 md:pb-24 bg-gradient-to-b from-primary/90 to-secondary/90 text-white">
        <div class="container mx-auto max-w-4xl">
            <div class="mb-8 text-center">
                <h1 class="text-[clamp(2rem,5vw,3.5rem)] font-bold leading-tight mb-4 text-shadow">计算机图形学中的微积分应用</h1>
                <p class="text-[clamp(1rem,2vw,1.25rem)] text-white/90 max-w-3xl mx-auto">
                    探索微积分如何成为现代计算机图形学的数学基础，从曲线曲面表示到物理模拟
                </p>
            </div>
            <div class="flex justify-center">
                <a href="#content" class="bg-white text-primary hover:bg-white/90 transition-colors font-medium px-6 py-3 rounded-lg shadow-lg">
                    开始学习 <i class="fa fa-arrow-down ml-2"></i>
                </a>
            </div>
        </div>
        
        <!-- 装饰图形 -->
        <div class="absolute -bottom-1 left-0 w-full h-20 bg-light rounded-t-[50%] transform translate-y-10"></div>
        <div class="absolute top-0 right-0 w-64 h-64 bg-accent/20 rounded-full filter blur-3xl -translate-y-1/2 translate-x-1/2"></div>
        <div class="absolute bottom-0 left-0 w-80 h-80 bg-primary/20 rounded-full filter blur-3xl translate-y-1/2 -translate-x-1/2"></div>
    </header>

    <!-- 主要内容 -->
    <main id="content" class="container mx-auto max-w-5xl px-6 py-16">
        <!-- 介绍部分 -->
        <section class="mb-16">
            <div class="flex flex-col md:flex-row items-center gap-8">
                <div class="md:w-1/2">
                    <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-6">计算机图形学与微积分的交汇</h2>
                    <p class="text-lg text-dark/80 mb-6 leading-relaxed">
                        计算机图形学是一个将数学、物理和计算机科学融合的领域，而微积分则是其核心数学工具之一。从简单的线条绘制到复杂的3D动画，微积分原理贯穿始终。
                    </p>
                    <p class="text-lg text-dark/80 mb-6 leading-relaxed">
                        本页面将探讨微积分在计算机图形学中的关键应用，包括曲线和曲面表示、变换矩阵、光照明模型、物理模拟等方面。
                    </p>
                    <div class="flex flex-wrap gap-3">
                        <span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">参数化曲线</span>
                        <span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">贝塞尔曲线</span>
                        <span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">曲面细分</span>
                        <span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">光照模型</span>
                        <span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">物理模拟</span>
                    </div>
                </div>
                <div class="md:w-1/2">
                    <div class="bg-white p-4 rounded-xl shadow-xl">
                        <div class="canvas-container">
                            <canvas id="introCanvas"></canvas>
                        </div>
                        <div class="mt-4 text-center text-sm text-dark/60">
                            计算机图形学中使用的参数化曲线示例
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 参数化曲线部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">参数化曲线与曲面</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    参数化曲线和曲面是计算机图形学中表示复杂形状的基础，它们完全基于微积分中的参数方程概念。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow">
                    <h3 class="text-xl font-bold text-primary mb-4">参数化曲线</h3>
                    <p class="text-dark/80 mb-4">
                        参数化曲线使用参数方程表示，形式为: <span class="math-formula">r(t) = (x(t), y(t), z(t))</span>，其中 t 是参数。
                    </p>
                    <div class="formula-animation mb-6 bg-light p-4 rounded-lg">
                        <p class="font-math text-center text-lg">
                            r(t) = x(t)i + y(t)j + z(t)k
                        </p>
                    </div>
                    <p class="text-dark/80">
                        这种表示方法使得我们可以精确控制曲线的形状，计算曲线的切线、法线和曲率，这对于计算机图形学中的路径规划、动画插值等非常重要。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow">
                    <h3 class="text-xl font-bold text-primary mb-4">参数化曲面</h3>
                    <p class="text-dark/80 mb-4">
                        类似地，参数化曲面使用两个参数表示: <span class="math-formula">r(u,v) = (x(u,v), y(u,v), z(u,v))</span>，其中 u 和 v 是参数。
                    </p>
                    <div class="formula-animation mb-6 bg-light p-4 rounded-lg">
                        <p class="font-math text-center text-lg">
                            r(u,v) = x(u,v)i + y(u,v)j + z(u,v)k
                        </p>
                    </div>
                    <p class="text-dark/80">
                        参数化曲面广泛应用于3D建模、动画和游戏开发中，允许艺术家创建复杂的曲面并进行精确控制。
                    </p>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">参数化曲线交互式演示</h3>
                <div class="canvas-container">
                    <canvas id="parametricCurveCanvas"></canvas>
                </div>
                <div class="mt-4 flex flex-wrap gap-4 justify-center">
                    <button id="lineButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">直线</button>
                    <button id="circleButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">圆</button>
                    <button id="helixButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">螺旋线</button>
                    <button id="bezierButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">贝塞尔曲线</button>
                </div>
            </div>
        </section>

        <!-- 贝塞尔曲线部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">贝塞尔曲线</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    贝塞尔曲线是计算机图形学中最常用的曲线表示方法之一，从矢量图形到字体渲染，从动画插值到3D建模，都离不开贝塞尔曲线。
                </p>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg mb-8">
                <h3 class="text-xl font-bold text-primary mb-4">贝塞尔曲线的数学原理</h3>
                <p class="text-dark/80 mb-6">
                    贝塞尔曲线基于伯恩斯坦多项式，可以用控制点来定义曲线形状。n次贝塞尔曲线由n+1个控制点定义，其参数方程为：
                </p>
                <div class="formula-animation bg-light p-6 rounded-lg text-center mb-6">
                    <p class="font-math text-xl">
                        B(t) = Σ<sub>i=0到n</sub> P<sub>i</sub> * C(n,i) * t<sup>i</sup> * (1-t)<sup>n-i</sup>
                    </p>
                </div>
                <p class="text-dark/80">
                    其中P<sub>i</sub>是控制点，C(n,i)是组合数，t∈[0,1]是参数。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">二次贝塞尔曲线</h3>
                    <p class="text-dark/80 mb-4">
                        二次贝塞尔曲线由3个控制点定义，其参数方程为：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            B(t) = (1-t)<sup>2</sup>P<sub>0</sub> + 2t(1-t)P<sub>1</sub> + t<sup>2</sup>P<sub>2</sub>
                        </p>
                    </div>
                    <p class="text-dark/80">
                        二次贝塞尔曲线常用于简单的曲线设计，如UI元素的圆角、路径规划等。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">三次贝塞尔曲线</h3>
                    <p class="text-dark/80 mb-4">
                        三次贝塞尔曲线由4个控制点定义，其参数方程为：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            B(t) = (1-t)<sup>3</sup>P<sub>0</sub> + 3t(1-t)<sup>2</sup>P<sub>1</sub> + 3t<sup>2</sup>(1-t)P<sub>2</sub> + t<sup>3</sup>P<sub>3</sub>
                        </p>
                    </div>
                    <p class="text-dark/80">
                        三次贝塞尔曲线是最常用的类型，在Adobe Illustrator、Sketch等设计软件中广泛使用，也是CSS动画中transition-timing-function的基础。
                    </p>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">三次贝塞尔曲线交互式演示</h3>
                <div class="canvas-container">
                    <canvas id="bezierCanvas"></canvas>
                </div>
                <div class="mt-4 text-center text-sm text-dark/60">
                    拖动控制点来调整贝塞尔曲线形状
                </div>
            </div>
        </section>

        <!-- 变换矩阵部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">变换矩阵与微积分</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    在计算机图形学中，变换矩阵用于表示平移、旋转、缩放等操作，这些操作背后也蕴含着微积分原理。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">线性变换与雅可比矩阵</h3>
                    <p class="text-dark/80 mb-4">
                        线性变换可以用矩阵表示，而雅可比矩阵则是描述非线性变换的关键工具。雅可比矩阵J定义为：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            J = [∂f<sub>i</sub>/∂x<sub>j</sub>]
                        </p>
                    </div>
                    <p class="text-dark/80">
                        雅可比矩阵在计算机图形学中用于纹理映射、网格变形等操作，帮助我们理解变换对周围点的影响。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">仿射变换</h3>
                    <p class="text-dark/80 mb-4">
                        仿射变换结合了线性变换和平移，可以用4×4矩阵表示3D空间中的变换：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            [x'; y'; z'; 1] = [x; y; z; 1] × M
                        </p>
                    </div>
                    <p class="text-dark/80">
                        仿射变换在3D图形学中至关重要，用于相机变换、模型变换和投影变换等。
                    </p>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">3D变换交互式演示</h3>
                <div class="canvas-container">
                    <canvas id="transformCanvas"></canvas>
                </div>
                <div class="mt-4 flex flex-wrap gap-4 justify-center">
                    <button id="rotateXButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">绕X轴旋转</button>
                    <button id="rotateYButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">绕Y轴旋转</button>
                    <button id="rotateZButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">绕Z轴旋转</button>
                    <button id="scaleButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">缩放</button>
                    <button id="resetTransformButton" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">重置</button>
                </div>
            </div>
        </section>

        <!-- 光照明模型部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">光照明模型</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    光照明模型用于计算物体表面的光照效果，是计算机图形学中实现真实感渲染的关键，而这些模型大多基于微积分原理。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">Phong光照模型</h3>
                    <p class="text-dark/80 mb-4">
                        Phong光照模型是最经典的光照模型之一，它将光照分为环境光、漫反射和镜面反射三部分：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            I = I<sub>a</sub> + I<sub>d</sub>(L·N) + I<sub>s</sub>(R·V)<sup>n</sup>
                        </p>
                    </div>
                    <p class="text-dark/80">
                        其中L是光源方向，N是法线方向，R是反射方向，V是视线方向，n是高光指数。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">BRDF模型</h3>
                    <p class="text-dark/80 mb-4">
                        双向反射分布函数(BRDF)是更通用的光照模型框架，它描述了入射光和反射光之间的关系：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            f(ω<sub>i</sub>, ω<sub>o</sub>) = dL<sub>o</sub>(ω<sub>o</sub>) / dE<sub>i</sub>(ω<sub>i</sub>)
                        </p>
                    </div>
                    <p class="text-dark/80">
                        BRDF在现代物理基于渲染(PBR)中广泛应用，能够更准确地模拟真实世界中的光照效果。
                    </p>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">光照模型交互式演示</h3>
                <div class="canvas-container">
                    <canvas id="lightingCanvas"></canvas>
                </div>
                <div class="mt-4 flex flex-wrap gap-4 justify-center">
                    <button id="moveLightButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">移动光源</button>
                    <button id="phongButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">Phong模型</button>
                    <button id="blinnPhongButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">Blinn-Phong模型</button>
                    <button id="toggleSpecularButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">切换高光</button>
                </div>
            </div>
        </section>

        <!-- 物理模拟部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">物理模拟中的微积分</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    计算机图形学中的物理模拟广泛应用微积分原理，从简单的粒子系统到复杂的流体动力学，都离不开微积分方程的数值解法。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">粒子系统与牛顿力学</h3>
                    <p class="text-dark/80 mb-4">
                        粒子系统基于牛顿第二定律F=ma，通过数值积分方法求解运动方程：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            m·d<sup>2</sup>r/dt<sup>2</sup> = F(r, v, t)
                        </p>
                    </div>
                    <p class="text-dark/80">
                        常用的数值积分方法包括欧拉法、龙格-库塔法等，它们都是基于微积分的数值近似方法。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">流体动力学</h3>
                    <p class="text-dark/80 mb-4">
                        流体模拟基于纳维-斯托克斯方程，这是一组描述流体运动的偏微分方程：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            ∂v/∂t + (v·∇)v = -∇p/ρ + ν∇<sup>2</sup>v + f
                        </p>
                    </div>
                    <p class="text-dark/80">
                        这些方程的数值解法是计算机图形学中实现烟雾、水等流体效果的基础。
                    </p>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">粒子系统交互式演示</h3>
                <div class="canvas-container">
                    <canvas id="particlesCanvas"></canvas>
                </div>
                <div class="mt-4 flex flex-wrap gap-4 justify-center">
                    <button id="addParticlesButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">添加粒子</button>
                    <button id="gravityButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">切换重力</button>
                    <button id="windButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">切换风力</button>
                    <button id="clearParticlesButton" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">清除粒子</button>
                </div>
            </div>
        </section>

        <!-- 细分曲面部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">细分曲面与曲线</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    细分曲面和曲线技术通过重复细化初始网格或多边形，生成光滑的曲面和曲线，这些技术也基于微积分原理。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">Catmull-Clark细分</h3>
                    <p class="text-dark/80 mb-4">
                        Catmull-Clark细分是一种用于四边形网格的细分方法，它通过在每个面的中心添加新顶点，然后重新定位所有顶点来生成更光滑的网格。
                    </p>
                    <p class="text-dark/80">
                        细分过程本质上是一个低通滤波操作，通过加权平均相邻顶点的位置，逐步消除高频细节，生成光滑曲面。
                    </p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold text-primary mb-4">B样条曲面</h3>
                    <p class="text-dark/80 mb-4">
                        B样条曲面是贝塞尔曲面的扩展，它通过基函数的局部支撑特性，允许更灵活地控制曲面形状：
                    </p>
                    <div class="formula-animation bg-light p-4 rounded-lg mb-4">
                        <p class="font-math text-center">
                            S(u,v) = Σ<sub>i=0到m</sub>Σ<sub>j=0到n</sub> P<sub>i,j</sub> N<sub>i,p</sub>(u) N<sub>j,q</sub>(v)
                        </p>
                    </div>
                    <p class="text-dark/80">
                        B样条曲面在CAD/CAM系统和3D建模软件中广泛应用，提供了比贝塞尔曲面更好的局部控制能力。
                    </p>
                </div>
            </div>
            
            <div class="mt-8 bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">细分曲面交互式演示</h3>
                <div class="canvas-container">
                    <canvas id="subdivisionCanvas"></canvas>
                </div>
                <div class="mt-4 flex flex-wrap gap-4 justify-center">
                    <button id="subdivideButton" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">细分</button>
                    <button id="resetSubdivisionButton" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">重置</button>
                    <select id="subdivisionType" class="px-4 py-2 border border-gray-300 rounded-lg">
                        <option value="catmull-clark">Catmull-Clark</option>
                        <option value="loop">Loop</option>
                    </select>
                </div>
            </div>
        </section>

        <!-- 实际应用案例部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">计算机图形学中的实际应用</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    微积分在计算机图形学中的应用非常广泛，从游戏开发到电影特效，从建筑设计到医学可视化，都离不开这些数学原理。
                </p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition-shadow">
                    <img src="https://picsum.photos/id/1/600/400" alt="3D建模" class="w-full h-48 object-cover">
                    <div class="p-6">
                        <h3 class="text-xl font-bold text-primary mb-3">3D建模与动画</h3>
                        <p class="text-dark/80">
                            3D建模软件使用贝塞尔曲线、NURBS曲面等技术创建复杂的3D模型，而动画系统则使用参数化曲线进行关键帧插值，这些都基于微积分原理。
                        </p>
                    </div>
                </div>
                
                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition-shadow">
                    <img src="https://picsum.photos/id/20/600/400" alt="计算机游戏" class="w-full h-48 object-cover">
                    <div class="p-6">
                        <h3 class="text-xl font-bold text-primary mb-3">计算机游戏</h3>
                        <p class="text-dark/80">
                            游戏中的物理引擎、角色动画、碰撞检测等系统都大量使用微积分原理，特别是数值积分方法来求解运动方程。
                        </p>
                    </div>
                </div>
                
                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition-shadow">
                    <img src="https://picsum.photos/id/96/600/400" alt="电影特效" class="w-full h-48 object-cover">
                    <div class="p-6">
                        <h3 class="text-xl font-bold text-primary mb-3">电影特效</h3>
                        <p class="text-dark/80">
                            现代电影中的逼真特效，如流体模拟、布料模拟、毛发渲染等，都基于复杂的物理模型和微积分方程的数值解法。
                        </p>
                    </div>
                </div>
                
                <div class="bg-white rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition-shadow">
                    <img src="https://picsum.photos/id/180/600/400" alt="计算机辅助设计" class="w-full h-48 object-cover">
                    <div class="p-6">
                        <h3 class="text-xl font-bold text-primary mb-3">计算机辅助设计</h3>
                        <p class="text-dark/80">
                            CAD系统使用NURBS曲面、贝塞尔曲线等技术进行精确的工程设计，这些技术完全基于微积分中的参数方程和曲面理论。
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- 未来发展趋势部分 -->
        <section class="mb-16">
            <div class="mb-10">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-4">计算机图形学的未来发展趋势</h2>
                <p class="text-lg text-dark/80 leading-relaxed">
                    随着计算机硬件的不断发展和算法的创新，计算机图形学正朝着更加真实、高效和智能化的方向发展。
                </p>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg mb-8">
                <h3 class="text-xl font-bold text-primary mb-4">深度学习与计算机图形学的结合</h3>
                <p class="text-dark/80 mb-4">
                    近年来，深度学习技术与计算机图形学的结合成为一个重要趋势，从图像生成到3D重建，从风格迁移到材质学习，都取得了显著进展。
                </p>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-light p-4 rounded-lg text-center">
                        <i class="fa fa-image text-primary text-3xl mb-2"></i>
                        <p class="text-dark/80 text-sm">图像生成</p>
                    </div>
                    <div class="bg-light p-4 rounded-lg text-center">
                        <i class="fa fa-cube text-primary text-3xl mb-2"></i>
                        <p class="text-dark/80 text-sm">3D重建</p>
                    </div>
                    <div class="bg-light p-4 rounded-lg text-center">
                        <i class="fa fa-paint-brush text-primary text-3xl mb-2"></i>
                        <p class="text-dark/80 text-sm">风格迁移</p>
                    </div>
                    <div class="bg-light p-4 rounded-lg text-center">
                        <i class="fa fa-magic text-primary text-3xl mb-2"></i>
                        <p class="text-dark/80 text-sm">材质学习</p>
                    </div>
                </div>
                <p class="text-dark/80">
                    尽管深度学习在某些任务上表现出色，但传统的基于微积分的图形学方法仍然是不可或缺的基础，两者的结合将推动计算机图形学的进一步发展。
                </p>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <h3 class="text-xl font-bold text-primary mb-4">实时渲染技术的发展</h3>
                <div class="canvas-container">
                    <canvas id="futureTrendsCanvas"></canvas>
                </div>
                <div class="mt-4">
                    <p class="text-dark/80">
                        随着GPU性能的不断提升和算法的优化，实时渲染技术正在迅速发展，从实时全局光照到实时路径追踪，都让实时渲染的质量越来越接近离线渲染。
                    </p>
                </div>
            </div>
        </section>

        <!-- 总结部分 -->
        <section class="mb-16">
            <div class="bg-gradient-to-r from-primary/10 to-secondary/10 p-8 rounded-xl">
                <h2 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-primary mb-6 text-center">总结与展望</h2>
                <div class="max-w-3xl mx-auto">
                    <p class="text-lg text-dark/80 mb-6 leading-relaxed">
                        微积分作为计算机图形学的数学基础，从参数化曲线到物理模拟，从光照明模型到曲面细分，都发挥着核心作用。理解这些数学原理，对于深入掌握计算机图形学技术至关重要。
                    </p>
                    <p class="text-lg text-dark/80 mb-6 leading-relaxed">
                        随着计算机图形学的不断发展，我们可以期待看到更真实、更高效、更智能的图形技术，而这些技术的发展，也将继续依赖于微积分等基础数学理论的深入应用和创新。
                    </p>
                    <div class="flex justify-center mt-8">
                        <a href="calculus-tutorial.html" class="bg-primary hover:bg-primary/90 transition-colors text-white font-medium px-6 py-3 rounded-lg shadow-lg">
                            返回微积分教程主页
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-12 px-6">
        <div class="container mx-auto max-w-5xl">
            <div class="grid md:grid-cols-3 gap-8">
                <div>
                    <div class="flex items-center space-x-2 mb-6">
                        <i class="fa fa-calculator text-secondary text-2xl"></i>
                        <h3 class="text-xl font-bold">微积分教程</h3>
                    </div>
                    <p class="text-white/70 mb-4">
                        探索微积分的奇妙世界，从基础概念到实际应用，助力您深入理解这一重要的数学分支。
                    </p>
                    <div class="flex space-x-4">
                        <a href="#" class="text-white/70 hover:text-white transition-colors">
                            <i class="fa fa-facebook"></i>
                        </a>
                        <a href="#" class="text-white/70 hover:text-white transition-colors">
                            <i class="fa fa-twitter"></i>
                        </a>
                        <a href="#" class="text-white/70 hover:text-white transition-colors">
                            <i class="fa fa-instagram"></i>
                        </a>
                        <a href="#" class="text-white/70 hover:text-white transition-colors">
                            <i class="fa fa-github"></i>
                        </a>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-bold mb-6">快速链接</h3>
                    <ul class="space-y-3">
                        <li><a href="calculus-tutorial.html" class="text-white/70 hover:text-white transition-colors">微积分教程主页</a></li>
                        <li><a href="calculus-tutorial.html#concepts" class="text-white/70 hover:text-white transition-colors">基本概念</a></li>
                        <li><a href="calculus-tutorial.html#applications" class="text-white/70 hover:text-white transition-colors">应用案例</a></li>
                        <li><a href="calculus-tutorial.html#exercises" class="text-white/70 hover:text-white transition-colors">练习题</a></li>
                        <li><a href="calculus-tutorial.html#resources" class="text-white/70 hover:text-white transition-colors">学习资源</a></li>
                    </ul>
                </div>
                
                <div>
                    <h3 class="text-lg font-bold mb-6">联系我们</h3>
                    <ul class="space-y-3">
                        <li class="flex items-start space-x-3">
                            <i class="fa fa-envelope text-secondary mt-1"></i>
                            <span class="text-white/70">contact@calculus-tutorial.com</span>
                        </li>
                        <li class="flex items-start space-x-3">
                            <i class="fa fa-phone text-secondary mt-1"></i>
                            <span class="text-white/70">+86 123 4567 8910</span>
                        </li>
                        <li class="flex items-start space-x-3">
                            <i class="fa fa-map-marker text-secondary mt-1"></i>
                            <span class="text-white/70">北京市海淀区中关村南大街5号</span>
                        </li>
                    </ul>
                </div>
            </div>
            
            <div class="border-t border-white/10 mt-10 pt-6 text-center text-white/50 text-sm">
                <p>© 2023 微积分教程 | 保留所有权利</p>
            </div>
        </div>
    </footer>

    <!-- JavaScript代码 -->
    <script>
        // 导航栏滚动效果
        window.addEventListener('scroll', function() {
            const navbar = document.getElementById('navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('navbar-scrolled');
            } else {
                navbar.classList.remove('navbar-scrolled');
            }
        });
        
        // 移动端菜单切换
        document.getElementById('menu-toggle').addEventListener('click', function() {
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenu.classList.toggle('hidden');
        });
        
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                if (targetId === '#') return;
                
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // 关闭移动端菜单
                    const mobileMenu = document.getElementById('mobile-menu');
                    if (!mobileMenu.classList.contains('hidden')) {
                        mobileMenu.classList.add('hidden');
                    }
                }
            });
        });
        
        // 介绍部分的画布
        const introCanvas = document.getElementById('introCanvas');
        const introCtx = introCanvas.getContext('2d');
        
        function drawIntroCanvas() {
            const width = introCanvas.width = introCanvas.parentElement.clientWidth;
            const height = introCanvas.height = introCanvas.parentElement.clientHeight;
            
            // 清除画布
            introCtx.clearRect(0, 0, width, height);
            
            // 设置样式
            introCtx.lineWidth = 3;
            introCtx.strokeStyle = '#3B82F6';
            
            // 绘制参数化曲线示例
            drawParametricCurve(introCtx, width, height);
        }
        
        function drawParametricCurve(ctx, width, height) {
            // 绘制贝塞尔曲线
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.8);
            ctx.bezierCurveTo(
                width * 0.3, height * 0.2,
                width * 0.7, height * 0.2,
                width * 0.9, height * 0.8
            );
            ctx.stroke();
            
            // 绘制控制点和控制线
            ctx.strokeStyle = '#94A3B8';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.8);
            ctx.lineTo(width * 0.3, height * 0.2);
            ctx.moveTo(width * 0.7, height * 0.2);
            ctx.lineTo(width * 0.9, height * 0.8);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // 绘制控制点
            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(width * 0.1, height * 0.8, 5, 0, 2 * Math.PI);
            ctx.arc(width * 0.3, height * 0.2, 5, 0, 2 * Math.PI);
            ctx.arc(width * 0.7, height * 0.2, 5, 0, 2 * Math.PI);
            ctx.arc(width * 0.9, height * 0.8, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制坐标轴
            ctx.strokeStyle = '#64748B';
            ctx.lineWidth = 1;
            
            // X轴
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.9);
            ctx.lineTo(width * 0.9, height * 0.9);
            ctx.stroke();
            
            // Y轴
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.1);
            ctx.lineTo(width * 0.1, height * 0.9);
            ctx.stroke();
            
            // 绘制标签
            ctx.fillStyle = '#334155';
            ctx.font = '12px Arial';
            ctx.fillText('参数化曲线示例', width / 2 - 40, height * 0.1);
            ctx.fillText('t', width * 0.95, height * 0.9);
            ctx.save();
            ctx.translate(width * 0.08, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('B(t)', 0, 0);
            ctx.restore();
        }
        
        // 参数化曲线交互式演示
        const parametricCurveCanvas = document.getElementById('parametricCurveCanvas');
        const parametricCurveCtx = parametricCurveCanvas.getContext('2d');
        let currentCurveType = 'circle';
        
        function drawParametricCurveDemo() {
            const width = parametricCurveCanvas.width = parametricCurveCanvas.parentElement.clientWidth;
            const height = parametricCurveCanvas.height = parametricCurveCanvas.parentElement.clientHeight;
            
            // 清除画布
            parametricCurveCtx.clearRect(0, 0, width, height);
            
            // 设置样式
            parametricCurveCtx.lineWidth = 3;
            parametricCurveCtx.strokeStyle = '#3B82F6';
            parametricCurveCtx.fillStyle = '#1E40AF';
            
            // 绘制不同类型的参数化曲线
            if (currentCurveType === 'line') {
                drawLine(parametricCurveCtx, width, height);
            } else if (currentCurveType === 'circle') {
                drawCircle(parametricCurveCtx, width, height);
            } else if (currentCurveType === 'helix') {
                drawHelix(parametricCurveCtx, width, height);
            } else if (currentCurveType === 'bezier') {
                drawDemoBezier(parametricCurveCtx, width, height);
            }
            
            // 绘制坐标轴
            parametricCurveCtx.strokeStyle = '#64748B';
            parametricCurveCtx.lineWidth = 1;
            
            // X轴
            parametricCurveCtx.beginPath();
            parametricCurveCtx.moveTo(width * 0.1, height * 0.9);
            parametricCurveCtx.lineTo(width * 0.9, height * 0.9);
            parametricCurveCtx.stroke();
            
            // Y轴
            parametricCurveCtx.beginPath();
            parametricCurveCtx.moveTo(width * 0.1, height * 0.1);
            parametricCurveCtx.lineTo(width * 0.1, height * 0.9);
            parametricCurveCtx.stroke();
        }
        
        function drawLine(ctx, width, height) {
            const startX = width * 0.2;
            const startY = height * 0.7;
            const endX = width * 0.8;
            const endY = height * 0.3;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // 绘制起点和终点
            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(startX, startY, 5, 0, 2 * Math.PI);
            ctx.arc(endX, endY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制参数方程
            ctx.fillStyle = '#334155';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('r(t) = (x0 + t(x1-x0), y0 + t(y1-y0))', width / 2, height * 0.1);
        }
        
        function drawCircle(ctx, width, height) {
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            const radius = Math.min(width, height) * 0.3;
            
            ctx.beginPath();
            for (let t = 0; t <= 2 * Math.PI; t += 0.01) {
                const x = centerX + radius * Math.cos(t);
                const y = centerY + radius * Math.sin(t);
                if (t === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制参数方程
            ctx.fillStyle = '#334155';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('r(t) = (r·cos(t), r·sin(t))', width / 2, height * 0.1);
        }
        
        function drawHelix(ctx, width, height) {
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            const radius = Math.min(width, height) * 0.2;
            const heightRange = height * 0.4;
            
            ctx.beginPath();
            for (let t = 0; t <= 4 * Math.PI; t += 0.01) {
                // 简化的2D螺旋表示
                const r = radius * (1 - t / (4 * Math.PI));
                const x = centerX + r * Math.cos(t);
                const y = centerY + heightRange * (t / (4 * Math.PI) - 0.5);
                if (t === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制参数方程
            ctx.fillStyle = '#334155';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('r(t) = (r·cos(t), r·sin(t), ht)', width / 2, height * 0.1);
        }
        
        function drawDemoBezier(ctx, width, height) {
            const p0 = {x: width * 0.2, y: height * 0.7};
            const p1 = {x: width * 0.4, y: height * 0.2};
            const p2 = {x: width * 0.6, y: height * 0.2};
            const p3 = {x: width * 0.8, y: height * 0.7};
            
            // 绘制贝塞尔曲线
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
            
            // 绘制控制线
            ctx.strokeStyle = '#94A3B8';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // 绘制控制点
            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(p0.x, p0.y, 5, 0, 2 * Math.PI);
            ctx.arc(p1.x, p1.y, 5, 0, 2 * Math.PI);
            ctx.arc(p2.x, p2.y, 5, 0, 2 * Math.PI);
            ctx.arc(p3.x, p3.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制参数方程
            ctx.fillStyle = '#334155';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('B(t) = (1-t)³P0 + 3t(1-t)²P1 + 3t²(1-t)P2 + t³P3', width / 2, height * 0.1);
        }
        
        // 贝塞尔曲线交互式演示
        const bezierCanvas = document.getElementById('bezierCanvas');
        const bezierCtx = bezierCanvas.getContext('2d');
        
        // 贝塞尔曲线控制点
        let bezierPoints = [
            {x: 100, y: 300, draggable: true},
            {x: 200, y: 50, draggable: true},
            {x: 400, y: 50, draggable: true},
            {x: 500, y: 300, draggable: true}
        ];
        let isDragging = false;
        let dragIndex = -1;
        
        function drawBezierCurve() {
            const width = bezierCanvas.width = bezierCanvas.parentElement.clientWidth;
            const height = bezierCanvas.height = bezierCanvas.parentElement.clientHeight;
            
            // 调整控制点位置以适应画布大小
            if (bezierPoints[0].x === 100) { // 仅在初始化时调整
                bezierPoints[0] = {x: width * 0.2, y: height * 0.7, draggable: true};
                bezierPoints[1] = {x: width * 0.4, y: height * 0.2, draggable: true};
                bezierPoints[2] = {x: width * 0.6, y: height * 0.2, draggable: true};
                bezierPoints[3] = {x: width * 0.8, y: height * 0.7, draggable: true};
            }
            
            // 清除画布
            bezierCtx.clearRect(0, 0, width, height);
            
            // 绘制贝塞尔曲线
            bezierCtx.strokeStyle = '#3B82F6';
            bezierCtx.lineWidth = 3;
            bezierCtx.beginPath();
            bezierCtx.moveTo(bezierPoints[0].x, bezierPoints[0].y);
            bezierCtx.bezierCurveTo(
                bezierPoints[1].x, bezierPoints[1].y,
                bezierPoints[2].x, bezierPoints[2].y,
                bezierPoints[3].x, bezierPoints[3].y
            );
            bezierCtx.stroke();
            
            // 绘制控制线
            bezierCtx.strokeStyle = '#94A3B8';
            bezierCtx.lineWidth = 1;
            bezierCtx.setLineDash([5, 5]);
            
            bezierCtx.beginPath();
            bezierCtx.moveTo(bezierPoints[0].x, bezierPoints[0].y);
            bezierCtx.lineTo(bezierPoints[1].x, bezierPoints[1].y);
            bezierCtx.moveTo(bezierPoints[2].x, bezierPoints[2].y);
            bezierCtx.lineTo(bezierPoints[3].x, bezierPoints[3].y);
            bezierCtx.stroke();
            
            bezierCtx.setLineDash([]);
            
            // 绘制控制点
            for (let i = 0; i < bezierPoints.length; i++) {
                bezierCtx.fillStyle = bezierPoints[i].draggable ? '#EF4444' : '#3B82F6';
                bezierCtx.beginPath();
                bezierCtx.arc(bezierPoints[i].x, bezierPoints[i].y, 6, 0, 2 * Math.PI);
                bezierCtx.fill();
                
                // 绘制控制点标签
                bezierCtx.fillStyle = '#334155';
                bezierCtx.font = '12px Arial';
                bezierCtx.fillText('P' + i, bezierPoints[i].x + 10, bezierPoints[i].y - 10);
            }
        }
        
        // 变换矩阵交互式演示
        const transformCanvas = document.getElementById('transformCanvas');
        const transformCtx = transformCanvas.getContext('2d');
        let rotationX = 0;
        let rotationY = 0;
        let rotationZ = 0;
        let scale = 1;
        
        function drawTransformDemo() {
            const width = transformCanvas.width = transformCanvas.parentElement.clientWidth;
            const height = transformCanvas.height = transformCanvas.parentElement.clientHeight;
            
            // 清除画布
            transformCtx.clearRect(0, 0, width, height);
            
            // 保存当前状态
            transformCtx.save();
            
            // 平移到画布中心
            transformCtx.translate(width / 2, height / 2);
            
            // 应用缩放
            transformCtx.scale(scale, scale);
            
            // 应用旋转变换
            transformCtx.rotate(rotationZ);
            
            // 绘制立方体的简化2D表示（正方形）
            const size = Math.min(width, height) * 0.3;
            
            // 绘制投影
            transformCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            transformCtx.beginPath();
            transformCtx.rect(-size/2, -size/2, size, size);
            transformCtx.fill();
            
            // 绘制边框
            transformCtx.strokeStyle = '#3B82F6';
            transformCtx.lineWidth = 3;
            transformCtx.beginPath();
            transformCtx.rect(-size/2, -size/2, size, size);
            transformCtx.stroke();
            
            // 绘制坐标轴
            transformCtx.strokeStyle = '#EF4444';
            transformCtx.lineWidth = 2;
            transformCtx.beginPath();
            transformCtx.moveTo(0, 0);
            transformCtx.lineTo(size/2, 0);
            transformCtx.stroke();
            
            transformCtx.strokeStyle = '#10B981';
            transformCtx.beginPath();
            transformCtx.moveTo(0, 0);
            transformCtx.lineTo(0, -size/2);
            transformCtx.stroke();
            
            // 绘制标签
            transformCtx.fillStyle = '#334155';
            transformCtx.font = '14px Arial';
            transformCtx.fillText('X', size/2 + 10, 5);
            transformCtx.fillText('Y', 5, -size/2 - 5);
            
            // 恢复状态
            transformCtx.restore();
        }
        
        // 光照模型交互式演示
        const lightingCanvas = document.getElementById('lightingCanvas');
        const lightingCtx = lightingCanvas.getContext('2d');
        let lightX = 1;
        let lightY = 1;
        let lightZ = 1;
        let lightingModel = 'phong';
        let showSpecular = true;
        
        function drawLightingDemo() {
            const width = lightingCanvas.width = lightingCanvas.parentElement.clientWidth;
            const height = lightingCanvas.height = lightingCanvas.parentElement.clientHeight;
            
            // 清除画布
            lightingCtx.clearRect(0, 0, width, height);
            
            // 光源位置归一化
            const len = Math.sqrt(lightX*lightX + lightY*lightY + lightZ*lightZ);
            const L = {x: lightX/len, y: lightY/len, z: lightZ/len};
            
            // 视线方向（假设从相机看向原点
            const V = {x: 0, y: 0, z: 1};
            
            // 绘制球体（简化为圆形）
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.3;
            
            // 绘制球体的渐变效果以模拟光照
            const gradient = lightingCtx.createRadialGradient(
                centerX - radius * L.x * 0.3,
                centerY - radius * L.y * 0.3,
                radius * 0.1,
                centerX,
                centerY,
                radius
            );
            
            // 计算漫反射颜色
            const N = {x: 0, y: 0, z: 1}; // 法线方向
            const diffuse = Math.max(0, N.x*L.x + N.y*L.y + N.z*L.z);
            
            // 计算镜面反射
            let specular = 0;
            if (showSpecular) {
                if (lightingModel === 'phong') {
                    // Phong模型：计算反射方向
                    const R = {
                        x: 2 * N.x * (N.x*L.x + N.y*L.y + N.z*L.z) - L.x,
                        y: 2 * N.y * (N.x*L.x + N.y*L.y + N.z*L.z) - L.y,
                        z: 2 * N.z * (N.x*L.x + N.y*L.y + N.z*L.z) - L.z
                    };
                    specular = Math.pow(Math.max(0, R.x*V.x + R.y*V.y + R.z*V.z), 32);
                } else if (lightingModel === 'blinn-phong') {
                    // Blinn-Phong模型：计算半程向量
                    const H = {
                        x: (L.x + V.x) / 2,
                        y: (L.y + V.y) / 2,
                        z: (L.z + V.z) / 2
                    };
                    specular = Math.pow(Math.max(0, N.x*H.x + N.y*H.y + N.z*H.z), 32);
                }
            }
            
            // 设置渐变颜色
            const diffuseColor = Math.floor(59 + diffuse * 100);
            const specularColor = Math.floor(200 + specular * 55);
            
            gradient.addColorStop(0, `rgb(${specularColor}, ${specularColor}, ${specularColor})`);
            gradient.addColorStop(0.3, `rgb(${diffuseColor}, ${diffuseColor + 71}, ${diffuseColor + 187})`);
            gradient.addColorStop(1, `rgb(${Math.floor(diffuseColor * 0.7)}, ${Math.floor((diffuseColor + 71) * 0.7)}, ${Math.floor((diffuseColor + 187) * 0.7)})`);
            
            // 绘制球体
            lightingCtx.fillStyle = gradient;
            lightingCtx.beginPath();
            lightingCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            lightingCtx.fill();
            
            // 绘制光源位置指示
            const lightIndicatorX = centerX + radius * 1.5 * L.x;
            const lightIndicatorY = centerY + radius * 1.5 * L.y;
            
            lightingCtx.fillStyle = '#FBBF24';
            lightingCtx.beginPath();
            lightingCtx.arc(lightIndicatorX, lightIndicatorY, 8, 0, 2 * Math.PI);
            lightingCtx.fill();
            
            // 绘制光源标签
            lightingCtx.fillStyle = '#334155';
            lightingCtx.font = '12px Arial';
            lightingCtx.fillText('光源', lightIndicatorX + 10, lightIndicatorY - 10);
            
            // 绘制光照方程
            lightingCtx.fillStyle = '#334155';
            lightingCtx.font = '14px Arial';
            lightingCtx.textAlign = 'center';
            if (lightingModel === 'phong') {
                lightingCtx.fillText('I = Iambient + Idiffuse(L·N) + Ispecular(R·V)^n', width / 2, height * 0.1);
            } else if (lightingModel === 'blinn-phong') {
                lightingCtx.fillText('I = Iambient + Idiffuse(L·N) + Ispecular(N·H)^n', width / 2, height * 0.1);
            }
        }
        
        // 粒子系统交互式演示
        const particlesCanvas = document.getElementById('particlesCanvas');
        const particlesCtx = particlesCanvas.getContext('2d');
        let particles = [];
        let gravity = true;
        let wind = false;
        
        function drawParticlesDemo() {
            const width = particlesCanvas.width = particlesCanvas.parentElement.clientWidth;
            const height = particlesCanvas.height = particlesCanvas.parentElement.clientHeight;
            
            // 清除画布
            particlesCtx.clearRect(0, 0, width, height);
            
            // 更新和绘制粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                // 应用重力
                if (gravity) {
                    p.vy += 0.2;
                }
                
                // 应用风力
                if (wind) {
                    p.vx += 0.1;
                }
                
                // 更新位置
                p.x += p.vx;
                p.y += p.vy;
                
                // 边界检测
                if (p.x < 0 || p.x > width || p.y > height) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // 绘制粒子
                particlesCtx.fillStyle = p.color;
                particlesCtx.beginPath();
                particlesCtx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                particlesCtx.fill();
            }
            
            // 绘制标题
            particlesCtx.fillStyle = '#334155';
            particlesCtx.font = '14px Arial';
            particlesCtx.textAlign = 'center';
            particlesCtx.fillText('粒子系统模拟', width / 2, height * 0.1);
        }
        
        function addParticles() {
            const width = particlesCanvas.parentElement.clientWidth;
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: width * 0.5,
                    y: particlesCanvas.parentElement.clientHeight * 0.1,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * -5,
                    size: Math.random() * 3 + 2,
                    color: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.8)`
                });
            }
        }
        
        // 细分曲面交互式演示
        const subdivisionCanvas = document.getElementById('subdivisionCanvas');
        const subdivisionCtx = subdivisionCanvas.getContext('2d');
        let subdivisionLevel = 0;
        let subdivisionType = 'catmull-clark';
        let mesh = [];
        
        function initializeMesh() {
            const width = subdivisionCanvas.parentElement.clientWidth;
            const height = subdivisionCanvas.parentElement.clientHeight;
            const size = Math.min(width, height) * 0.3;
            const centerX = width / 2;
            const centerY = height / 2;
            
            mesh = [
                [{x: centerX - size, y: centerY - size}, {x: centerX + size, y: centerY - size}],
                [{x: centerX - size, y: centerY + size}, {x: centerX + size, y: centerY + size}]
            ];
            subdivisionLevel = 0;
        }
        
        function drawSubdivisionDemo() {
            const width = subdivisionCanvas.width = subdivisionCanvas.parentElement.clientWidth;
            const height = subdivisionCanvas.height = subdivisionCanvas.parentElement.clientHeight;
            
            // 清除画布
            subdivisionCtx.clearRect(0, 0, width, height);
            
            // 绘制网格
            subdivisionCtx.strokeStyle = '#3B82F6';
            subdivisionCtx.lineWidth = 2;
            
            for (let i = 0; i < mesh.length; i++) {
                for (let j = 0; j < mesh[i].length - 1; j++) {
                    subdivisionCtx.beginPath();
                    subdivisionCtx.moveTo(mesh[i][j].x, mesh[i][j].y);
                    subdivisionCtx.lineTo(mesh[i][j+1].x, mesh[i][j+1].y);
                    subdivisionCtx.stroke();
                }
            }
            
            for (let j = 0; j < mesh[0].length; j++) {
                for (let i = 0; i < mesh.length - 1; i++) {
                    subdivisionCtx.beginPath();
                    subdivisionCtx.moveTo(mesh[i][j].x, mesh[i][j].y);
                    subdivisionCtx.lineTo(mesh[i+1][j].x, mesh[i+1][j].y);
                    subdivisionCtx.stroke();
                }
            }
            
            // 绘制细分级别
            subdivisionCtx.fillStyle = '#334155';
            subdivisionCtx.font = '14px Arial';
            subdivisionCtx.textAlign = 'center';
            subdivisionCtx.fillText(`细分级别: ${subdivisionLevel} (${subdivisionType})`, width / 2, height * 0.1);
        }
        
        function subdivideMesh() {
            const newMesh = [];
            
            // 简化的细分实现（仅演示用）
            for (let i = 0; i < mesh.length; i++) {
                const newRow = [];
                for (let j = 0; j < mesh[i].length; j++) {
                    newRow.push({...mesh[i][j]});
                    
                    // 在每两个顶点之间添加新顶点
                    if (j < mesh[i].length - 1) {
                        const midX = (mesh[i][j].x + mesh[i][j+1].x) / 2;
                        const midY = (mesh[i][j].y + mesh[i][j+1].y) / 2;
                        newRow.push({x: midX, y: midY});
                    }
                }
                newMesh.push(newRow);
                
                // 在每两行之间添加新行
                if (i < mesh.length - 1) {
                    const midRow = [];
                    for (let j = 0; j < mesh[i].length; j++) {
                        const midX = (mesh[i][j].x + mesh[i+1][j].x) / 2;
                        const midY = (mesh[i][j].y + mesh[i+1][j].y) / 2;
                        midRow.push({x: midX, y: midY});
                        
                        if (j < mesh[i].length - 1) {
                            const centerX = (mesh[i][j].x + mesh[i][j+1].x + mesh[i+1][j].x + mesh[i+1][j+1].x) / 4;
                            const centerY = (mesh[i][j].y + mesh[i][j+1].y + mesh[i+1][j].y + mesh[i+1][j+1].y) / 4;
                            midRow.push({x: centerX, y: centerY});
                        }
                    }
                    newMesh.push(midRow);
                }
            }
            
            mesh = newMesh;
            subdivisionLevel++;
        }
        
        // 未来趋势图表
        const futureTrendsCanvas = document.getElementById('futureTrendsCanvas');
        
        function drawFutureTrendsChart() {
            const width = futureTrendsCanvas.width = futureTrendsCanvas.parentElement.clientWidth;
            const height = futureTrendsCanvas.height = futureTrendsCanvas.parentElement.clientHeight;
            
            // 销毁旧图表（如果存在）
            if (window.futureTrendsChart) {
                window.futureTrendsChart.destroy();
            }
            
            // 创建新图表
            window.futureTrendsChart = new Chart(futureTrendsCanvas, {
                type: 'line',
                data: {
                    labels: ['2010', '2012', '2014', '2016', '2018', '2020', '2022', '2024', '2026', '2028', '2030'],
                    datasets: [
                        {
                            label: '实时渲染质量',
                            data: [20, 25, 30, 38, 45, 55, 65, 75, 83, 90, 95],
                            borderColor: '#3B82F6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'AI在图形学中的应用',
                            data: [5, 8, 12, 18, 25, 35, 50, 68, 80, 88, 93],
                            borderColor: '#10B981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: '物理模拟复杂度',
                            data: [15, 20, 28, 35, 42, 50, 60, 68, 75, 82, 88],
                            borderColor: '#EF4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '技术成熟度 (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '年份'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: '计算机图形学技术发展趋势预测',
                            font: {
                                size: 16
                            }
                        }
                    }
                }
            });
        }
        
        // 事件监听器
        document.getElementById('lineButton').addEventListener('click', function() {
            currentCurveType = 'line';
            drawParametricCurveDemo();
        });
        
        document.getElementById('circleButton').addEventListener('click', function() {
            currentCurveType = 'circle';
            drawParametricCurveDemo();
        });
        
        document.getElementById('helixButton').addEventListener('click', function() {
            currentCurveType = 'helix';
            drawParametricCurveDemo();
        });
        
        document.getElementById('bezierButton').addEventListener('click', function() {
            currentCurveType = 'bezier';
            drawParametricCurveDemo();
        });
        
        // 贝塞尔曲线交互
        bezierCanvas.addEventListener('mousedown', function(e) {
            const rect = bezierCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            for (let i = 0; i < bezierPoints.length; i++) {
                const dx = bezierPoints[i].x - x;
                const dy = bezierPoints[i].y - y;
                if (Math.sqrt(dx*dx + dy*dy) <= 10 && bezierPoints[i].draggable) {
                    isDragging = true;
                    dragIndex = i;
                    break;
                }
            }
        });
        
        window.addEventListener('mousemove', function(e) {
            if (isDragging && dragIndex !== -1) {
                const rect = bezierCanvas.getBoundingClientRect();
                bezierPoints[dragIndex].x = e.clientX - rect.left;
                bezierPoints[dragIndex].y = e.clientY - rect.top;
                drawBezierCurve();
            }
        });
        
        window.addEventListener('mouseup', function() {
            isDragging = false;
            dragIndex = -1;
        });
        
        // 变换矩阵交互
        document.getElementById('rotateXButton').addEventListener('click', function() {
            rotationX += Math.PI / 6;
            drawTransformDemo();
        });
        
        document.getElementById('rotateYButton').addEventListener('click', function() {
            rotationY += Math.PI / 6;
            drawTransformDemo();
        });
        
        document.getElementById('rotateZButton').addEventListener('click', function() {
            rotationZ += Math.PI / 6;
            drawTransformDemo();
        });
        
        document.getElementById('scaleButton').addEventListener('click', function() {
            scale = scale === 1 ? 1.2 : 1;
            drawTransformDemo();
        });
        
        document.getElementById('resetTransformButton').addEventListener('click', function() {
            rotationX = 0;
            rotationY = 0;
            rotationZ = 0;
            scale = 1;
            drawTransformDemo();
        });
        
        // 光照模型交互
        document.getElementById('moveLightButton').addEventListener('click', function() {
            lightX = Math.random() * 2 - 1;
            lightY = Math.random() * 2 - 1;
            lightZ = Math.random() * 2 - 1;
            drawLightingDemo();
        });
        
        document.getElementById('phongButton').addEventListener('click', function() {
            lightingModel = 'phong';
            drawLightingDemo();
        });
        
        document.getElementById('blinnPhongButton').addEventListener('click', function() {
            lightingModel = 'blinn-phong';
            drawLightingDemo();
        });
        
        document.getElementById('toggleSpecularButton').addEventListener('click', function() {
            showSpecular = !showSpecular;
            drawLightingDemo();
        });
        
        // 粒子系统交互
        document.getElementById('addParticlesButton').addEventListener('click', function() {
            addParticles();
        });
        
        document.getElementById('gravityButton').addEventListener('click', function() {
            gravity = !gravity;
        });
        
        document.getElementById('windButton').addEventListener('click', function() {
            wind = !wind;
        });
        
        document.getElementById('clearParticlesButton').addEventListener('click', function() {
            particles = [];
        });
        
        // 细分曲面交互
        document.getElementById('subdivideButton').addEventListener('click', function() {
            if (subdivisionLevel < 3) { // 限制细分级别以避免性能问题
                subdivideMesh();
                drawSubdivisionDemo();
            }
        });
        
        document.getElementById('resetSubdivisionButton').addEventListener('click', function() {
            initializeMesh();
            drawSubdivisionDemo();
        });
        
        document.getElementById('subdivisionType').addEventListener('change', function() {
            subdivisionType = this.value;
            initializeMesh();
            drawSubdivisionDemo();
        });
        
        // 窗口大小改变时重绘所有画布
        window.addEventListener('resize', function() {
            drawIntroCanvas();
            drawParametricCurveDemo();
            drawBezierCurve();
            drawTransformDemo();
            drawLightingDemo();
            drawSubdivisionDemo();
            drawFutureTrendsChart();
        });
        
        // 页面加载时初始化
        window.addEventListener('load', function() {
            drawIntroCanvas();
            drawParametricCurveDemo();
            drawBezierCurve();
            drawTransformDemo();
            drawLightingDemo();
            initializeMesh();
            drawSubdivisionDemo();
            drawFutureTrendsChart();
            
            // 粒子系统动画循环
            function animate() {
                drawParticlesDemo();
                requestAnimationFrame(animate);
            }
            animate();
        });